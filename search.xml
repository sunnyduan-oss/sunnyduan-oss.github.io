<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图的应用</title>
      <link href="/2024/11/22/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2024/11/22/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Stochastic Methods in Machine Learning: Outline</title>
      <link href="/2024/11/22/Stochastic-Methods-in-Machine-Learning-Outline/"/>
      <url>/2024/11/22/Stochastic-Methods-in-Machine-Learning-Outline/</url>
      
        <content type="html"><![CDATA[<h1 id="Stochastic-Methods-in-Machine-Learning-Outline"><a href="#Stochastic-Methods-in-Machine-Learning-Outline" class="headerlink" title="Stochastic Methods in Machine Learning: Outline"></a>Stochastic Methods in Machine Learning: Outline</h1><p>几个细分topics之间的关系和逻辑。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能基础 </tag>
            
            <tag> HKU ARIN7011 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Constrained Nonlinear Optimization</title>
      <link href="/2024/11/21/Constrained-Nonlinear-Optimization/"/>
      <url>/2024/11/21/Constrained-Nonlinear-Optimization/</url>
      
        <content type="html"><![CDATA[<h1 id="Constrained-Nonlinear-Optimization"><a href="#Constrained-Nonlinear-Optimization" class="headerlink" title="Constrained Nonlinear Optimization"></a>Constrained Nonlinear Optimization</h1><p>该文章思路是解决有限制条件的优化问题的方法。</p><p>这部分是非线性优化（针对任意函数$f(x)$）的有附加限制条件的优化。</p><p>有限制条件的非线性优化问题的形式：</p><script type="math/tex; mode=display">\min_x f(x) \\s.t \ g_i(x) \leq 0,\ i=1,...,m \\h_i(x)=0, \ i=1,...,p</script><p>其中，$f(x)$是目标函数；$m$个不等式限制方程$g_i$；$p$个等式限制方程$h_i$。</p><p>对于限制优化问题，也有$Lagrangian$方程：</p><script type="math/tex; mode=display">L(x,\lambda,\mu)=f(x)+\sum_{i=1}^m \lambda_i g_i(x)+\sum_{i=1}^p \mu_i h_i(x)</script><p>对于每个限制方程，都有一个对应的对偶变量($dual\ variable$)：$\lambda_i$是$g_i(x)$的对偶变量，$\mu_i$是$h_i(x)$的对偶变量。</p><p>如何将$Lagrangian$方程$L(x,\lambda,\mu)$和原始优化方程$f(x)$联系起来呢？</p><script type="math/tex; mode=display">\max_{\lambda \geq 0,\mu} L(x,\lambda,\mu)=\begin{cases}  f(x), & if\ x\ is\ feasible \\  \infty, & otherwise\end{cases}</script><p>所以，<script type="math/tex">\min_{x \in \Omega}f(x)=\min_{x}\max_{\lambda \geq 0,\mu} L(x,\lambda,\mu)</script></p><p>在一些假设下，可以交换最大化和最小化顺序：</p><script type="math/tex; mode=display">\min_{x}\max_{\lambda \geq 0,\mu} L(x,\lambda,\mu)=\max_{\lambda \geq 0,\mu}\min_{x} L(x,\lambda,\mu)</script><h2 id="KKT-Karush-Kuhn-Tucker-Conditions"><a href="#KKT-Karush-Kuhn-Tucker-Conditions" class="headerlink" title="KKT(Karush-Kuhn-Tucker) Conditions"></a>KKT(Karush-Kuhn-Tucker) Conditions</h2><p>满足KKT Conditions的$x^<em>$的点的意义：在给定的约束条件下，$x^</em>$是目标函数局部最优解的候选点。</p><p>Active Set: </p><h2 id="对偶"><a href="#对偶" class="headerlink" title="对偶"></a>对偶</h2><p>对偶目标函数：</p><script type="math/tex; mode=display">q(\lambda,\mu)=\min_x L(x,\lambda,\mu)</script><p>所以，对偶问题的形式是：</p><script type="math/tex; mode=display">\max_{\lambda \geq 0,\mu} q(\lambda,\mu)</script><p>弱对偶性：对偶的目标函数的值比原始函数的值小，</p><script type="math/tex; mode=display">q(\lambda,\mu) \leq f(x)</script><p>强对偶性：在一些条件下(Slater’s condition)，有，</p><script type="math/tex; mode=display">q(\lambda^*,\mu^*)=f(x^*)</script><h2 id="优化问题-Optimization-Problem-的应用：支持向量机-Support-Vector-Machine"><a href="#优化问题-Optimization-Problem-的应用：支持向量机-Support-Vector-Machine" class="headerlink" title="优化问题(Optimization Problem)的应用：支持向量机(Support Vector Machine)"></a>优化问题(Optimization Problem)的应用：支持向量机(Support Vector Machine)</h2><h3 id="Hard-Margin-SVM"><a href="#Hard-Margin-SVM" class="headerlink" title="Hard-Margin SVM"></a>Hard-Margin SVM</h3><p>SVM: primal optimization problem</p><script type="math/tex; mode=display">\max_{x,b} 2/ \|x\| \\s.t. \ y^i(x^\mathrm{T}s^i+b) \geq 1.</script><p>将最大化转化成最小化：</p><script type="math/tex; mode=display">\min_{x,b} \|x\|^2 /2\\s.t. \ 1-y^i(x^\mathrm{T}s^i+b) \leq 0.</script><p>SVM: Dual Optimization Problem</p><h3 id="Soft-Margin-SVM"><a href="#Soft-Margin-SVM" class="headerlink" title="Soft-Margin SVM"></a>Soft-Margin SVM</h3><h2 id="投影梯度法-Projected-Gradient-Mathod"><a href="#投影梯度法-Projected-Gradient-Mathod" class="headerlink" title="投影梯度法(Projected Gradient Mathod)"></a>投影梯度法(Projected Gradient Mathod)</h2><p>gradient descent + projection</p><p>什么是投影projection? 对于一个给定的点$x$，投影操作通常是找到一个点$x’$，使得$x’$在可行域内，并且距离$x$最近。所以，投影是<strong>满足限制条件的点</strong>中<strong>距离最近</strong>的。</p><p>投影梯度法有两个步骤：</p><ul><li>执行无限制的梯度下降步骤：$x^{k+ {1\over 2}}=x^k-\eta_k\nabla f(x^k)$</li><li>计算在可行域$\Omega$上的投影：$x^{k+1}\in arg \min_{x\in \Omega}|x-x^{k+{1\over 2}}|$</li></ul><p>PGD法只在投影操作cheap的时候有效。</p><h2 id="SVM问题的解决方法：PGD"><a href="#SVM问题的解决方法：PGD" class="headerlink" title="SVM问题的解决方法：PGD"></a>SVM问题的解决方法：PGD</h2><h2 id="交替方向乘数法-ADMM-alternating-direction-method-of-multipliers"><a href="#交替方向乘数法-ADMM-alternating-direction-method-of-multipliers" class="headerlink" title="交替方向乘数法(ADMM, alternating direction method of multipliers)"></a>交替方向乘数法(ADMM, alternating direction method of multipliers)</h2><h3 id="对偶问题-Dual-Problem"><a href="#对偶问题-Dual-Problem" class="headerlink" title="对偶问题(Dual Problem)"></a>对偶问题(Dual Problem)</h3><p>原始问题：</p><script type="math/tex; mode=display">\min_{x\in R^n} f(x)\ s.t.\ Ax=b</script><p>$Lagrangin$方程：</p><script type="math/tex; mode=display">L(x,\lambda)=f(x)+\lambda^\mathrm{T}(Ax-b)</script><script type="math/tex; mode=display">q(\lambda)=\min_{x\in R^n}\ L(x,\lambda)</script><p>对偶方程：</p><script type="math/tex; mode=display">\max_{\lambda}\ q(\lambda)</script><p>得到对偶问题的解$\lambda^*$：</p><script type="math/tex; mode=display">\lambda^*=arg\max_\lambda\ q(\lambda)</script><p>最终可以求得原始问题的解$x^*$：</p><script type="math/tex; mode=display">x^*=arg\min_{x\in R^n}\ L(x,\lambda^*)</script><p>如何求解$\lambda^*$？使用梯度上升的方法。</p><h3 id="对偶上升-Dual-Ascent-：如何基于-lambda-k-求-lambda-k-1"><a href="#对偶上升-Dual-Ascent-：如何基于-lambda-k-求-lambda-k-1" class="headerlink" title="对偶上升(Dual Ascent)：如何基于$\lambda^k$求$\lambda^{k+1}$"></a>对偶上升(Dual Ascent)：如何基于$\lambda^k$求$\lambda^{k+1}$</h3><p>如何计算$\nabla q(\lambda^k)$？</p><p>已知$q(\lambda)=\min_{x\in R^n} L(x,\lambda)$，假设$\tilde{x}=arg\min_x L(x,\lambda)$，所以$q(\lambda)$可以改写为：</p><script type="math/tex; mode=display">q(\lambda)=L(\tilde{x},\lambda)=f(\tilde{x})+\lambda^\mathrm{T}(A\tilde{x}-b).</script><p>方程的梯度（$q(\lambda)$对$\lambda$求导）是：</p><script type="math/tex; mode=display">\nabla q(\lambda)=A\tilde{x}-b</script><p>所以，对偶上升法的步骤是：</p><h3 id="对偶分解-Dual-Decomposition"><a href="#对偶分解-Dual-Decomposition" class="headerlink" title="对偶分解(Dual Decomposition)"></a>对偶分解(Dual Decomposition)</h3><p>假设方程$f(x_1,x_2,…,x_N)$是separable的，说明$f(x)$可以被分解成多个方程的乘积或和：</p><script type="math/tex; mode=display">f(x_1,x_2,...,x_N)=g_1(x_1)\times g_2(x_2) \times ... \times g_N(x_N)</script><script type="math/tex; mode=display">f(x_1,x_2,...,x_N)=g_1(x_1)+g_2(x_2)+...+g_N(x_N)</script><p>对偶分解指可以通过分解$Lagrangin$方程到各个维度<strong>分解对偶问题</strong>（假设变量$x$是$N$维向量），分解的原理如下：</p><script type="math/tex; mode=display">f(x)=g_1(x_{(1)})+g_2(x_{(2)})+...+g_N(x_{(N)}),\ where\ x=(x_{(1)},x_{(2)},...,x_{(N)})^\mathrm{T}</script><p>所以，我们可以得到：</p><script type="math/tex; mode=display">\lambda^\mathrm{T}Ax=\lambda^\mathrm{T}(A_1,...,A_N)\begin{pmatrix}x_{(1)} \\... \\x_{(N)}\end{pmatrix}=\lambda^\mathrm{T}A_ix_{(i)}</script><p>$Lagrangin$方程是separable的，我们可以得到：</p><script type="math/tex; mode=display">L(x,\lambda)=L_1(x_{(1)},\lambda)+...+L_N(x_{(N)},\lambda),\ L_i(x_{(i)},\lambda)=g_i(x_{(i)})+\lambda^\mathrm{T}(A_ix_{(i)}-b_{(i)})</script><p>可以将$x=(x_1,x_2,…,x_N)$的最小化分解为$N$个分离的最小化问题，其中第$i$维变量在第$k+1$轮次的最小化问题是：</p><script type="math/tex; mode=display">(x^{k+1})_i=arg\min_{x_{(i)}}\ L_i(x_{(i)},\lambda^k)</script><p>其中，$\lambda^k$是第$k$轮求得的对偶问题的结果。</p><h3 id="乘数方法-Methods-of-Multipliers"><a href="#乘数方法-Methods-of-Multipliers" class="headerlink" title="乘数方法(Methods of Multipliers)"></a>乘数方法(Methods of Multipliers)</h3><p>对$Lagangin$方程<strong>新增一项$(\rho / 2)| Ax-b |^2$</strong>，可以得到$Augmented\ Lagrangin$：</p><script type="math/tex; mode=display">L_\rho(x,\lambda)=f(x)+\lambda^\mathrm{T}(Ax-b)+(\rho / 2)\| Ax-b \|^2</script><p>所以，原始优化问题是：</p><script type="math/tex; mode=display">\min_x f(x)+(\rho / 2)\| Ax-b \|^2\ s.t.\ Ax-b=0</script><h4 id="乘数方法步骤"><a href="#乘数方法步骤" class="headerlink" title="乘数方法步骤"></a>乘数方法步骤</h4><ul><li>第一步是$x$的最小化操作。</li><li>第二步是对偶变量上升操作，在对偶上升中将$\eta<em>k=\rho$，以及$\nabla L</em>\rho(x,\lambda)=Ax^{k+1}-b$。</li></ul><p>$for\ k=0,1,…,K-1\ do \<br>\qquad Set\ x^{k+1}=arg\min<em>x L</em>{\rho}(x,\lambda^k) \<br>\qquad Set\ \lambda^{k+1}=\lambda^k+\rho(Ax^{k+1}-b)<br>$</p><h3 id="交替方向乘数方法-ADMM-Alternating-Direction-Method-of-Multipliers"><a href="#交替方向乘数方法-ADMM-Alternating-Direction-Method-of-Multipliers" class="headerlink" title="交替方向乘数方法(ADMM,Alternating Direction Method of Multipliers)"></a>交替方向乘数方法(ADMM,Alternating Direction Method of Multipliers)</h3><p>该方法用于处理两个变量$x$和$z$的优化问题。</p><p>主要(Primal)优化问题：</p><script type="math/tex; mode=display">\min_{x,z} f(x)+g(z)\ s.t.\ Ax+Bz=c</script><p>The augmented Lagrangin is:</p><script type="math/tex; mode=display">L_\rho(x,z,\lambda)=f(x)+g(z)+\lambda^\mathrm{T}(Ax+Bz-c)+(\rho / 2)\| Ax+Bz-b \|^2 \\\nabla L_\rho(\lambda)=Ax+Bz-c</script><h4 id="ADMM"><a href="#ADMM" class="headerlink" title="ADMM"></a>ADMM</h4><h4 id="ADMM方法的最优解的条件"><a href="#ADMM方法的最优解的条件" class="headerlink" title="ADMM方法的最优解的条件"></a>ADMM方法的最优解的条件</h4><h4 id="缩放对偶变量的ADMM方法"><a href="#缩放对偶变量的ADMM方法" class="headerlink" title="缩放对偶变量的ADMM方法"></a>缩放对偶变量的ADMM方法</h4><p>将$u^k=\rho^{-1}\lambda^k$操作称为缩放对偶变量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能基础 </tag>
            
            <tag> HKU ARIN7011 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的遍历</title>
      <link href="/2024/11/20/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2024/11/20/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>图的遍历指的是从某一顶点出发，按照某种搜索方法访问图中的所有顶点，有且仅访问一次。</p><h2 id="广度优先搜索-BFS-Breadth-First-Search"><a href="#广度优先搜索-BFS-Breadth-First-Search" class="headerlink" title="广度优先搜索(BFS, Breadth-First-Search)"></a>广度优先搜索(BFS, Breadth-First-Search)</h2><p>类似于二叉树的按层遍历的算法。基本思想：以$v$为起始点，由近至远依次访问和$v$有路径相通且路径长度为$1,2,…$的顶点。使用<strong>队列</strong>实现广度优先搜索算法。</p><p>BFS算法的空间复杂度最坏情况是$O(|V|)$，因为辅助队列最坏情况保存所有顶点。采用邻接表存储时，算法时间复杂度是$O(|V|+|E|)$。</p><p>广度优先搜索方向的应用有求解<strong>最短路径</strong>问题。</p><h3 id="广度优先树"><a href="#广度优先树" class="headerlink" title="广度优先树"></a>广度优先树</h3><p>在广度遍历的过程中，得到的树，称为广度优先生成树。</p><h2 id="深度优先搜索-Depth-First-Search-DFS"><a href="#深度优先搜索-Depth-First-Search-DFS" class="headerlink" title="深度优先搜索(Depth-First-Search, DFS)"></a>深度优先搜索(Depth-First-Search, DFS)</h2><p>类似于二叉树的先序遍历，尽量<strong>深</strong>地搜索一个图。基本思想：以$v$为起始点，访问与$v$邻接且未被访问的任意一个顶点$w_1$，再访问与$w_1$邻接且未被访问的任意一个顶点$w_2$…重复以上过程。当不能继续向下访问的时候，依次<strong>退到最近被访问的顶点</strong>，若它还有未被访问的邻接顶点，则从该点继续上述搜索过程，直到整张图均被访问过为止。</p><h3 id="DFS算法复杂度分析"><a href="#DFS算法复杂度分析" class="headerlink" title="DFS算法复杂度分析"></a>DFS算法复杂度分析</h3><p>需要访问$|V|$个顶点，访问<strong>每个顶点的时间复杂度是$T_v=O(1+deg(v))$</strong>，其中$1$指的是访问顶点操作的时间复杂度，$deg(v)$指的是访问相邻结点的时间复杂度。</p><script type="math/tex; mode=display">T=\sum_{v\in V} T \leq \sum_{v\in V} O(1+deg(v))</script><script type="math/tex; mode=display">= \sum_{v\in V}O(1)+\sum_{v\in V}O(deg(v))=O(|V|)+O(|E|)=O(|V|+|E|)</script><h3 id="深度优先树"><a href="#深度优先树" class="headerlink" title="深度优先树"></a>深度优先树</h3><h2 id="图的遍历算法的应用"><a href="#图的遍历算法的应用" class="headerlink" title="图的遍历算法的应用"></a>图的遍历算法的应用</h2><p>图的遍历算法可以用来<strong>判断图的连通性</strong>。如果图是连通的，则一次访问即可访问图中的所有顶点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning-Unet</title>
      <link href="/2024/11/18/Deep-Learning-Unet/"/>
      <url>/2024/11/18/Deep-Learning-Unet/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning-Vision-Visualization and Applications</title>
      <link href="/2024/11/18/Deep-Learning-Vision-Visualization-and-Applications/"/>
      <url>/2024/11/18/Deep-Learning-Vision-Visualization-and-Applications/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning-Vision-AlexNet to Resnet</title>
      <link href="/2024/11/18/Deep-Learning-Vision-AlexNet-to-Resnet/"/>
      <url>/2024/11/18/Deep-Learning-Vision-AlexNet-to-Resnet/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning-Vision-CNN</title>
      <link href="/2024/11/18/Deep-Learning-Vision-CNN/"/>
      <url>/2024/11/18/Deep-Learning-Vision-CNN/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning-Generative AI</title>
      <link href="/2024/11/18/Deep-Learning-Generative-AI/"/>
      <url>/2024/11/18/Deep-Learning-Generative-AI/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning-NLP-Transformer</title>
      <link href="/2024/11/18/Deep-Learning-NLP-Transformer/"/>
      <url>/2024/11/18/Deep-Learning-NLP-Transformer/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Deep Laerning-NLP-RNN/LSTM &amp; Word Embeddings</title>
      <link href="/2024/11/18/Deep-Laerning-NLP-RNN-LSTM-Word-Embeddings/"/>
      <url>/2024/11/18/Deep-Laerning-NLP-RNN-LSTM-Word-Embeddings/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning-Neural Networks</title>
      <link href="/2024/11/18/Deep-Learning-Neural-Networks/"/>
      <url>/2024/11/18/Deep-Learning-Neural-Networks/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning-Outline</title>
      <link href="/2024/11/18/Deep-Learning-Outline/"/>
      <url>/2024/11/18/Deep-Learning-Outline/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-Outline"><a href="#Deep-Learning-Outline" class="headerlink" title="Deep Learning: Outline"></a>Deep Learning: Outline</h1><h2 id="Course-Introduction"><a href="#Course-Introduction" class="headerlink" title="Course Introduction"></a>Course Introduction</h2><p>我将课程内容分为几个部分：</p><ul><li>Introduction：Introduce the development of AI, Linear models for regression &amp; classification. 其中第一部分需要了解AI，ML和DL之间的关系，第二部分比较简单，在很多课程里都提过。</li><li>Neural Networks: Basics, Backpropagation, Training and Batch Normalization. 这部分是对神经网络的介绍，是后续模型的基础。</li><li>Vision: CNN(Important), AlexNet to Resnet, Visualization &amp; Application.这部分是计算机视觉相关的内容，第一部分是CV的基础网络CNN，紧接着是图像网络的发展，最后一部分是可视化和应用。</li><li>Generative AI：这部分是生成式AI的部分。</li><li>Natural Language Processing: RNN/LSTM &amp; Word Embeddings, Transformer</li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Development-of-AI"><a href="#Development-of-AI" class="headerlink" title="Development of AI"></a>Development of AI</h3><p>我们可以从artificial intelligence, machine learning and deep learning三个主题理解AI的发展。</p><p>Artificial Intelligence: 人工智能是指使<strong>计算机或机器</strong>模拟人类智能的能力，包括学习、推理、问题解决、理解自然语言、感知和与环境互动等。</p><p>Machine Learning: 机器学习是人工智能的一个子领域，是指一种使计算机系统能够<strong>从数据中学习并做出决策或预测的技术</strong>。通过识别数据中的模式和规律，机器能够在未见过的数据上进行推断。</p><p>Deep Learning: 深度学习是机器学习的一个子领域，专注于使用<strong>多层神经网络</strong>来学习和表示数据中的复杂模式和特征。它通过模拟人脑神经元的工作方式，自动从大量数据中提取特征并进行决策。</p><p>三者之间逐层递进的区别：<br>在机器学习领域中，features是手工设计的，ML是学习如何将features映射到输出。</p><p>在深度学习领域中，features是通过学习得到的，并且应用了多个层用于多个级别的特征。即，在DL中，模型会主动学习特征，并且模型有很多层，每一层都有每一层的特征。</p><p><strong>机器学习是人工智能的一个分支，深度学习是机器学习的一个分支。</strong></p><p>有关深度学习的主题包含了：</p><ul><li>计算机视觉(Vision)：和图像相关。</li><li>生成式AI(Generative AI)：通俗来讲就是从头开始生成特定的东西，可以是图像，可以是文字等。</li><li>自然语言处理(Natural Language Process)</li><li><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HKU DASC7606 </tag>
            
            <tag> 人工智能基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue+Flask前后端分离开发</title>
      <link href="/2024/11/14/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/11/14/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-Flask前后端分离开发"><a href="#Vue-Flask前后端分离开发" class="headerlink" title="Vue+Flask前后端分离开发"></a>Vue+Flask前后端分离开发</h1><p>POST: 客户端向服务端提交数据。</p><p>GET：客户端从服务端获取数据。</p><p>Flask框架是一个由Python所构写的一个Web微框架。</p><h2 id="Flask框架连接MySQL数据库"><a href="#Flask框架连接MySQL数据库" class="headerlink" title="Flask框架连接MySQL数据库"></a>Flask框架连接MySQL数据库</h2><p>使用PyMySQL包操纵MySQL数据库。</p><h2 id="Flask框架常用函数"><a href="#Flask框架常用函数" class="headerlink" title="Flask框架常用函数"></a>Flask框架常用函数</h2><p>render_template_string: </p><h2 id="HTTP协议状态码"><a href="#HTTP协议状态码" class="headerlink" title="HTTP协议状态码"></a>HTTP协议状态码</h2><ul><li>200：</li></ul><h2 id="Vue框架"><a href="#Vue框架" class="headerlink" title="Vue框架"></a>Vue框架</h2><h3 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h3><h2 id="如何添加缓存"><a href="#如何添加缓存" class="headerlink" title="如何添加缓存"></a>如何添加缓存</h2><p>使用session保存在后端文件全局变量中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT-Powered Data Analysis on Customer Click</title>
      <link href="/2024/11/13/ChatGPT-Powered-Data-Analysis-on-Customer-Click/"/>
      <url>/2024/11/13/ChatGPT-Powered-Data-Analysis-on-Customer-Click/</url>
      
        <content type="html"><![CDATA[<h1 id="ChatGPT-Powered-Data-Analysis-on-Customer-Click"><a href="#ChatGPT-Powered-Data-Analysis-on-Customer-Click" class="headerlink" title="ChatGPT-Powered Data Analysis on Customer Click"></a>ChatGPT-Powered Data Analysis on Customer Click</h1><h2 id="Bacis-Requirements"><a href="#Bacis-Requirements" class="headerlink" title="Bacis Requirements"></a>Bacis Requirements</h2><p>This project involves building a simple data analysis tool that leverages ChatGPT for interactive data exploration. It will involves data science and API usage, focusing on creating a user-friendly application. In this project,<br>we want to do the <strong>Clickstream</strong> analysis with the help of ChatGPT.</p><p>You are expected to:</p><ol><li>Develop a Basic Web Application using Flask:<ol><li>Set up a simple <strong>Flask app</strong> for handling data uploads and ChatGPT interactions.</li><li>Implement basic user authentication with login functionality.</li></ol></li><li>Integrate ChatGPT API:<ol><li>Connect to the ChatGPT API(or passing the message to the ChatGPT web) for processing <strong>user queries related to data analysis</strong>.</li><li>Allow users to ask questions about datasets and receive insights.</li></ol></li><li>Data Upload and Processing:<ol><li>Enable users to <strong>upload datasets</strong> in CSV format.</li><li>Use Pandas for <strong>basic data operations</strong> like summary statistics and data cleaning.</li></ol></li><li>Interactive Data Visualization:<ol><li>Provide <strong>simple visualizations</strong> using libraries like Matplotlib or Plotly.</li><li><strong>Update charts</strong> based on user input and ChatGPT suggestions.</li></ol></li><li>Security and User Experience:<ol><li>Ensure secure data handling with basic validation.</li><li>Implement a user-friendly interface with clear instructions.</li></ol></li><li>Data Analysis Summary: After the data analysis, it requires to <strong>answer some basic questions</strong> about the Customer, for example:</li></ol><ul><li>How often the same customer revisiting the store (online or physical), how often the same customer revisiting the store (online or physical)</li><li>How is the customers’ sentiment according to the consumer’s comments/comment scores on products in social media dataset.</li><li>The customers’ shopping behaviors based on their clickstream (e.g. visit frequency, visit location and duration, web browsing/location<br>history, purchasing items, demographics, etc.)</li><li>Which kind of product of the customer will buy in the near future</li></ul><h2 id="Project-Analysis"><a href="#Project-Analysis" class="headerlink" title="Project Analysis"></a>Project Analysis</h2><p>Datasets: Clickstream</p><p>Steps:</p><ol><li>user registration and login</li><li>clickstream data upload</li><li>data analysis using Python</li><li>simple visualizations using Python</li><li>answer some basic questions besed on the result of data analysis by integrating ChatGPT API</li></ol><p>Questions:</p><ol><li>“Ensure secure data handling with basic validation”是什么意思？</li></ol><p>技术栈：</p><ul><li>前端：Vue框架 + Axios(http库)</li><li>后端：Flask框架 + MySQL数据库</li></ul><p>HTTP客户端：实际上就是前端，使用Axios和Vue框架集成</p><p>HTTP服务器端：Flask框架 + MySQL数据库</p><p>进阶：Running Flask on <strong>Kubernetes</strong></p><p>Axios是一个前端库，主要用于在浏览器中发送HTTP请求。它可以让你通过JavaScript与<strong>后端服务器</strong>进行通信，获取数据或提交信息。</p><p>Yarn是一个JavaScript包管理工具。管理和JavaScript相关的包。类似于Python中的pip，也是一个包管理工具。其实还是使用npm包进行安装。</p><p>Node是什么？Node.js是一个开源的、跨平台的 JavaScript运行时环境。可以说，JavaScript借助Node.js的编译器在机器上运行。</p><h3 id="用户登录和注册"><a href="#用户登录和注册" class="headerlink" title="用户登录和注册"></a>用户登录和注册</h3><p>登录：用户名username 和 密码password<br>注册：用户名username 和 密码password 和 邮箱email</p><p>密码存储时，需要对原始密码进行加密，下面是加密用的包<br>from werkzeug.security import generate_password_hash, check_password_hash</p>]]></content>
      
      
      
        <tags>
            
            <tag> STAT7008 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找</title>
      <link href="/2024/11/13/%E6%9F%A5%E6%89%BE/"/>
      <url>/2024/11/13/%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>查找属于数据结构主题中<strong>操作</strong>维度的知识。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树进阶和树的应用</title>
      <link href="/2024/11/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/11/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的进阶"><a href="#二叉树的进阶" class="headerlink" title="二叉树的进阶"></a>二叉树的进阶</h1><h2 id="二叉查找树-Binary-Search-Tree-BST"><a href="#二叉查找树-Binary-Search-Tree-BST" class="headerlink" title="二叉查找树(Binary Search Tree, BST)"></a>二叉查找树(Binary Search Tree, BST)</h2><p>二叉查找树，也称二叉排序树。其特性是：</p><ul><li>若左子树非空，则左子树上所有结点的值均小于根结点的值。</li><li>若右子树非空，则右子树上所有结点的值均大于根结点的值。</li><li>左右子树也分别是二叉查找树。</li></ul><p>二叉查找树的基本操作的时间复杂度和树的高度成正比，即对于一棵$n$个结点的完全二叉树，操作的最坏运行时间是$O(\log_2 n)$。</p><h3 id="二叉查找树的构造"><a href="#二叉查找树的构造" class="headerlink" title="二叉查找树的构造"></a>二叉查找树的构造</h3><p>设$K=(k_1,k_2,k_3,…,k_n)$为具有$n$个数据元素的序列。从序列的第一个元素开始，依次取序列中的元素，按照下述原则将$k_i$插入到二叉树中:</p><ul><li>若二叉树非空，则$k_i$作为二叉查找树的根结点。</li><li>若二叉树非空，则将$k_i$与该二叉树的根结点的值进行比较, 若$k_i$小于根结点的值,则将$k_i$插入到根结点的左子树中；否则,将$k_i$插入到根结点的右子树中。将$k_i$按照上述原则递归插入到左子树或者右子树中。</li></ul><h3 id="二叉查找树的插入"><a href="#二叉查找树的插入" class="headerlink" title="二叉查找树的插入"></a>二叉查找树的插入</h3><p>原理和构造一致。</p><p><em>二叉查找树新结点的插入也有递归算法和非递归算法。</em></p><h3 id="二叉查找树的删除"><a href="#二叉查找树的删除" class="headerlink" title="二叉查找树的删除"></a>二叉查找树的删除</h3><p>删除原则：</p><ol><li>被删除结点为叶结点，则直接删除；</li><li>被删除结点无左子树,则用右子树的根结点取代被删除结点；</li><li>被删除结点无右子树，则用左子树的根结点取代被删除结点；</li><li>被删除结点的左、右子树都存在，则用被删除结点的右子树中值最小的结点（或被删除结点的左子树中值最大的结点）取代被删除结点。<em><strong>因为是最小/最大的结点，所以选择的是子树的叶结点。</strong></em></li></ol><h3 id="二叉查找树的查找"><a href="#二叉查找树的查找" class="headerlink" title="二叉查找树的查找"></a>二叉查找树的查找</h3><p>查找原则：</p><ol><li>若二叉查找树为空，则查找失败。</li><li>若二叉查找树非空，则将被查找元素与二叉排序树的根结点的值进行比较：  <ul><li>若等于根结点的值,则查找成功；</li><li>若小于根结点的值,则到根结点的左子树中重复上述查找过程;</li><li>若大于根结点的值,则到根结点的右子树中重复上述查找过程;</li></ul></li></ol><p><em>二叉查找树新结点的查找也有递归算法和非递归算法。</em></p><h4 id="查找效率"><a href="#查找效率" class="headerlink" title="查找效率"></a>查找效率</h4><p>平均查找长度(Average Search Length, ASL)：确定一个元素在树中位置所需要进行的元素间的比较次数的期望值(平均值)。<br>计算公式：</p><script type="math/tex; mode=display">ASL= \sum_{i=1}^n p_ic_i</script><p>其中，$n$是二叉树中结点的总数；$p_i$表示查找第$i$个元素的概率；$c_i$表示查找第$i$个元素需要进行的元素之间的比较次数。</p><h3 id="普通二叉树的缺陷"><a href="#普通二叉树的缺陷" class="headerlink" title="普通二叉树的缺陷"></a>普通二叉树的缺陷</h3><p>假设被插入的元素序列是单调序列，那么就成为了退化二叉树，查找时间复杂度为$O(n)$。为了应对左右子树深度差距较大的情况，引入了平衡二叉树。</p><h2 id="平衡二叉树（Adelson-Velskii-and-Landis-AVL）"><a href="#平衡二叉树（Adelson-Velskii-and-Landis-AVL）" class="headerlink" title="平衡二叉树（Adelson-Velskii and Landis, AVL）"></a>平衡二叉树（Adelson-Velskii and Landis, AVL）</h2><p>平衡二叉树又称AVL树。它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且<strong>左子树和右子树的深度之差的绝对值不超过$1$</strong>。</p><p>平衡因子：结点的左右子树的高度差称为结点的平衡因子。\<br>左旋：\<br>右旋：\<br>参考文章：<a href="https://blog.csdn.net/m0_57466457/article/details/127400601" target="_blank" rel="noopener">https://blog.csdn.net/m0_57466457/article/details/127400601</a></p><h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h3><p>插入原则：</p><ol><li>将新结点按照二叉树的插入原则插入到平衡二叉树中；</li><li>检查新结点插入路径上的结点是否因为此次操作导致了不平衡，若导致了不平衡，则先找到插入路径上<strong>离插入结点最近</strong>的平衡因子的绝对值大于$1$的结点$A$；</li><li>对以$A$为根的子树，在保持二叉查找树的前提下，按照规律调整结点的位置关系。</li></ol><p>调整规律：</p><ol><li>LL平衡旋转（右单旋转）</li><li>RR平衡旋转（左单旋转）</li><li>LR平衡旋转</li><li>RL平衡旋转</li></ol><p><em>绘制旋转图解</em></p><h3 id="平衡二叉树的删除"><a href="#平衡二叉树的删除" class="headerlink" title="平衡二叉树的删除"></a>平衡二叉树的删除</h3><p>删除原则：</p><ol><li>使用二叉查找树的方式对结点$w$进行删除操作。</li><li>若导致了不平衡，则从结点$w$向上回溯，找到第一个不平衡的结点$z$。对以结点$z$为根的二叉树进行调整操作。</li></ol><h3 id="平衡二叉树的缺陷"><a href="#平衡二叉树的缺陷" class="headerlink" title="平衡二叉树的缺陷"></a>平衡二叉树的缺陷</h3><p>为了保持二叉树的平衡，在每次插入和删除操作后，会非常频繁地调整全树的拓扑结构，代价较大，所以引入了红黑树的结构。</p><h2 id="红黑树-Red-Black-Tree"><a href="#红黑树-Red-Black-Tree" class="headerlink" title="红黑树(Red Black Tree)"></a>红黑树(Red Black Tree)</h2><p>红黑树是一种二叉查找树，在每个结点上添加一个存储位表示结点的颜色，$Red$或$Black$。并且，引入外部叶结点($NIL$)，保证红黑树的每个内部结点的左、右孩子均非空。</p><p>红黑树的的红黑性质：</p><ul><li>性质1：每个结点只有红色和黑色。</li><li>性质2：根结点是黑色的。</li><li>性质3：外部叶结点都是黑色的。</li><li>性质4：不存在两个相邻的红结点。（红色父结点的两个孩子均为黑色）</li><li>性质5：对每个结点，从该结点到<strong>任意一个叶结点</strong>的简单路径上，所含黑结点的数量相同。</li></ul><p><em>简单路径：其中每个结点只能被访问一次，且没有重复的边的路径。</em></p><h3 id="红黑树的结点插入"><a href="#红黑树的结点插入" class="headerlink" title="红黑树的结点插入"></a>红黑树的结点插入</h3><p>新插入红黑树的结点初始着为红色。新结点的插入容易破坏<strong>性质4</strong>，出现两个连续的红色结点，所以需要使用染色和旋转的方式使之重新满足红黑树的性质。</p><p>设新插入的结点$z$：</p><ol><li>用二叉查找树插入法插入，并将结点$z$着为红色，若结点$z$的父结点是黑色，无需调整。</li><li>若结点$z$是根结点，则将$z$着为黑色，结束。</li><li>若结点$z$不是根结点，且$z$的父结点是红色的，分为三种情况，区别在于叔结点$y$的颜色不同。<ol><li>叔结点$y$是黑色的，$z$是一个右孩子：（父结点+$z$结点）先左旋，整体再右旋。<strong>（旋转）</strong></li><li>叔结点$y$是黑色的，$z$是一个左孩子：整体右旋。<strong>（旋转）</strong></li><li>叔结点$y$是红色的：父结点和叔结点染成黑色，爷结点染成红色。<strong>（染色）</strong></li></ol></li></ol><p><em>手绘结点插入的示意图。</em></p><h3 id="红黑树的结点删除"><a href="#红黑树的结点删除" class="headerlink" title="红黑树的结点删除"></a>红黑树的结点删除</h3><p>如果说插入新结点可能导致两个连续的红结点，那么删除的结点是黑结点的话，会破坏<strong>性质5</strong>。</p><p><em>后续二轮复习学习。</em></p><h1 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h1><h2 id="哈夫曼树-Huffman-Tree"><a href="#哈夫曼树-Huffman-Tree" class="headerlink" title="哈夫曼树(Huffman Tree)"></a>哈夫曼树(Huffman Tree)</h2><p>路径：从树的一个结点到另一个结点之间的分支。</p><p>路径长度：路径上的分支数目。</p><p>权：树中结点被赋予的一个表示某种意义的<strong>值</strong>。</p><p>带权路径长度(Weighted Path Length)：所有叶结点的带权路径长度之和。</p><script type="math/tex; mode=display">WPL=\sum_{i=0}^n w_il_i</script><p>其中，$w_i$是第$i$个叶结点的权，$l_i$是叶结点到根结点的路径长度。</p><p>在含有$n$个带权叶结点的二叉树中，带权路径长度最小的二叉树称为哈夫曼树。</p><h3 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h3><p>给定$n$个权值分别$w_1,w_2,…,w_n$的结点，构造哈夫曼树的算法如下：</p><ol><li>将这$n$个结点分别作为$n$棵含有一个结点的二叉树，构成森林$F$。</li><li>构造一个新结点，从$F$中选取根结点权值最小的两棵二叉树作为新结点的左右子树，并且将新结点的权值设置为左、右两棵子树的根结点权值和。</li><li>从F中删去选取的两棵树，同时将新得到的树加入$F$中。</li><li>重复步骤2和3，直到$F$中只剩下一棵树为止。</li></ol><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>在数据通信中，如果对每个字符用长度相等的二进制位表示，则称为固定长度编码；如果不等长，则称为可变长度编码。</p><p>前缀编码：没有一个编码是另外一个编码的前缀。</p><p>二叉树可以实现二进制前缀编码。</p><p>哈夫曼编码：假设我们需要对一个单词编码，每个待编码的字符都是哈夫曼树的叶结点，结点的权值是它出现的频次。</p><p>哈夫曼树的带权路径长度可视为最终编码得到的二进制编码的长度，即各个字符的编码长度 × 字符出现的频次。</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种简单的<strong>集合</strong>表示，它支持以下三种操作：</p><ol><li>初始化：将集合$S$中的每个元素都初始化只有一个单元素的子集合。</li><li>合并子集合：把集合$S$中的子集合$S_2$并入子集合$S_1$，要求这两个子集合不相交。</li><li>查找某个元素：查找集合$S$中某个元素所在的子集合，并返回<strong>该子集合的根结点</strong>。</li></ol><h3 id="并查集的实现"><a href="#并查集的实现" class="headerlink" title="并查集的实现"></a>并查集的实现</h3><p>定义父结点指针数组$Father[SIZE]$，$Father[i]$代表集合中第$i$个元素的父结点，如果该结点是根结点，则$Father[i]=-1$。</p><h4 id="并查集的初始化"><a href="#并查集的初始化" class="headerlink" title="并查集的初始化"></a>并查集的初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">    Father[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并查集的合并-Union"><a href="#并查集的合并-Union" class="headerlink" title="并查集的合并(Union)"></a>并查集的合并(Union)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root1 == root2) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father[root2] = root1;</span><br></pre></td></tr></table></figure><p>合并操作的时间复杂度是$O(1)$。</p><h4 id="并查集的查找-Find"><a href="#并查集的查找-Find" class="headerlink" title="并查集的查找(Find)"></a>并查集的查找(Find)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(Father[node] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 还有父结点</span></span><br><span class="line">    node = Father[node]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br></pre></td></tr></table></figure><p>查找操作的时间复杂度是$O(d)$，$d$为树的深度。</p><p>在极端情况下，$n$个元素构成的集合树深度为$n$，那么查找操作的最坏时间复杂度是$O(n)$，所以需要对并查集的操作进行优化。</p><h3 id="并查集实现的优化"><a href="#并查集实现的优化" class="headerlink" title="并查集实现的优化"></a>并查集实现的优化</h3><p>优化思路：在合并操作前判断两个子集的元素数量，令成员少的根指向成员多的根，即把小树合并到大树。可以开一个数据保存根结点的的元素数量$Member[SIZE]$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/2024/11/12/%E5%A0%86/"/>
      <url>/2024/11/12/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h1><p>堆是一种特殊类型的二叉树，堆具备两个性质：</p><ul><li>每个结点的值大于（或小于）等于其每个子结点的值；</li><li>该二叉树是平衡二叉树。</li></ul><p>如果根结点包含了最大的元素，则是大顶堆(max heap)；反之，是小顶堆（min heap）。</p><p>堆结构的最大好处是元素查找、插入和删除效率高($O(\log_2 n)$)。</p><p>堆<strong>按层的顺序</strong>存储在一个一维数组里$heap[SIZE]$。</p><p>如何根据结点序号求父结点序号？序号为$i(i&gt;0)$的结点父结点序号是$i-1 \over 2$。</p><p>如何根据结点序号求子结点序号？序号为$i$（不是叶结点）的元素子结点序号是$2i+1$和$2i+2$。</p><h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><h3 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h3><p>以大顶堆为例：先将待新结点$e$放在堆的末尾，如果$e$不是根结点，并且比父结点的值大，就和父结点交换。</p><h3 id="堆的删除"><a href="#堆的删除" class="headerlink" title="堆的删除"></a>堆的删除</h3><p>删除指删除堆顶元素。</p><p>以大顶堆为例：将最后一个叶结点中的元素放到要删除的元素位置（指堆顶），删除最后一个叶结点，将根元素$p$在不是叶结点的条件下，如果小于子结点，就和子结点的值交换，直到满足堆的条件。</p><h3 id="堆的构造"><a href="#堆的构造" class="headerlink" title="堆的构造"></a>堆的构造</h3><p>堆有两种构造方法，分别是自顶向下和自底向上。<br>自顶向下构造法的原理是<strong>堆的插入算法</strong>；自底向上构造法的原理是从底层开始构造较小的堆，然后再重复构造较大的堆。</p><h2 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h2><h3 id="优先队列-Priority-Queue"><a href="#优先队列-Priority-Queue" class="headerlink" title="优先队列(Priority Queue)"></a>优先队列(Priority Queue)</h3><p>与传统队列不同的是下一个服务对象是队列中<strong>优先级最高的元素</strong>。优先队列常用的实现方式是用堆，其最大好处是管理元素的效率高，时间复杂度是$O(\log_2 n)$。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol><li>将原始序列转换为一个堆，称为原始堆，原始堆的根元素（序列的首元素）是最大元素。</li><li>将堆的首元素与当前堆的尾元素交换位置。（将当前最大元素放在当前序列的末端）</li><li>将“去掉”最大值元素后剩下的元素组成的<strong>子序列</strong>重新转换一个新的堆。</li><li>重复上述过程的第2至第3步n−1次。</li></ol><p>堆排序的时间复杂度是$O(n\log_2 n)$，空间复杂度是$O(1)$（）无需额外辅助空间，堆排序是不稳定的。</p><h2 id="二顶堆"><a href="#二顶堆" class="headerlink" title="二顶堆"></a>二顶堆</h2><h2 id="斐波那契堆"><a href="#斐波那契堆" class="headerlink" title="斐波那契堆"></a>斐波那契堆</h2><p><em>两个堆还没细看，等二轮复习的时候来填坑。</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习路线</title>
      <link href="/2024/11/11/C-%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/"/>
      <url>/2024/11/11/C-%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="C-学习思路"><a href="#C-学习思路" class="headerlink" title="C++学习思路"></a>C++学习思路</h1><p>每学习一门语言都有一门语言的学习路线。我认为C++的学习路线是：C++基础，C++高级编程（面向对象）以及 C++标准库（STL源码剖析）。前两个阶段采用《C++ primer》和《Effective C++》这两本书，配合黑马程序员视频和侯捷的视频。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础</title>
      <link href="/2024/11/11/C-%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/11/11/C-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的基本概念和图的存储</title>
      <link href="/2024/11/09/%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/09/%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图$G$由顶点（数据元素）集$V$和边集（顶点之间的关系）$E$组成，即为$G=(V,E)$。若$V={v_1,v_2,…,v_n}$，则用$|V|$表示图中的顶点个数，$E={(u,v)|u \in V,v \in V}$。顶点集$V$必须是非空集合。</p><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul><li>有向图：$(u,v)$和$(v,u)$被视作同一条边，其中$u \in V, v \in V$。</li><li>无向图：$(u,v)$和$(v,u)$是两条不同的边，其中$u \in V, v \in V$。</li><li>相邻(Adjacent)：边$(u,v)$连接的顶点$u$和$v$相邻。相邻是顶点和顶点间的关系。</li><li>关联(Incident)：边$(u,v)$和其连接的顶点$u$（或$v$）相互关联。</li><li>简单图：不存在重复边和自环的图。</li><li>完全图：任意两个点之间都存在边。<ul><li>无向图的完全图：有$n(n-1)/2$条边的无向图。</li><li>有向图的完全图：有$n(n-1)$条边的有向图。</li></ul></li><li>子图：设两个图$G=(V,E)$和$G’=(V’,E’)$，若$V’$是$V$的子集，$E’$是$E$的子集，则称$G’$是$G$的子图。<strong>若满足$V(G’)=v(G)$，则称$G’$是$G$的生成子图</strong>。</li><li>顶点的度(Degree of a Vertex)：顶点$u$的度$deg(u)$是和$u$关联的边的数量。</li><li>图的度：图各顶点的度之和，即$deg(G)=\sum_{v \in V}deg(v)$。和树的度定义不一样。</li><li>握手定理(Handshaking Lemma)：无向图的度是边数的两倍，即$deg(G)=2|E|$。</li><li>路径(Path)：顶点$v<em>p$到顶点$v_p$之间的路径是指<strong>顶点序列</strong>$&lt;v_p,v</em>{i<em>1},v</em>{i<em>2},…,v</em>{i<em>m},v_q&gt;$。存在路径$&lt;v_p,v</em>{i<em>1},v</em>{i<em>2},…,v</em>{i_m},v_q&gt;$，说明$v_p$<strong>可达</strong>$v_q$。</li><li>路径长度：路径上的边的数量。</li><li>回路：第一个顶点和最后一个顶点相同的路径。若一个图有$n$个顶点，且有大于$n-1$条边，则图中一定有环。</li><li>简单路径：顶点不重复出现的路径。</li><li>简单回路：除了第一个顶点和最后一个顶点，其余顶点不重复出现的回路。</li><li>连通、连通图和连通分量：针对<strong>无向图</strong>的概念。<ul><li>若顶点$v$到顶点$u$有路径存在，则称$v$和$u$是连通的。</li><li>若图$G$中任意两个顶点都是相通的，则称图$G$是连通图。</li><li>连通分量(Connected Components)：根据是否连通将顶点进行分组，相互可达的<strong>顶点集</strong>和<strong>对应的边集</strong>称为连通分量。</li><li>极小连通子图：子图连通，且包含最少的边。</li><li>极大连通子图：子图连通，且包含最多的边。</li><li>无向图中的极大连通子图称为极大连通分量。</li></ul></li><li>强连通、强连通图和强连通分量：针对<strong>有向图</strong>的概念。<ul><li>若一对顶点$v$和$u$，从$v$到$u$和从$u$到$v$之间都有路径，则称这两个顶点是强连通的。</li><li>若图中任意一对顶点都是强连通的，则称此图为强连通图。</li><li>有向图中的极大强连通子图称为图的强连通分量。</li><li>极小强连通子图：子图强连通，包含最少的边。</li><li>极大强连通子图：子图强连通连通，包含最多的边。</li></ul></li><li>生成树：连通图（说明是无向图）的生成树是包含图中全部顶点的一个<strong>极小连通子图</strong>。若图中有$n$个结点，则它的生成树有$n-1$条边。</li><li>生成森林：在非连通图中，连通分量的生成树构成了非连通图的生成森林。</li><li>距离：从顶点$v$到顶点$u$存在的<strong>最短路径</strong>。</li><li>有向树：<em>有向图在什么条件下成为了有向树。</em> 一个顶点的入度为0，其余顶点的入度均为1，称为有向树。</li></ul><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><p>逻辑结构——图，在计算机物理内存内如何存储。如何在计算机内存中存储图里数据元素之间的逻辑关系。</p><p>需要思考的点：为什么有这种存储方式？每个存储方式的优势和劣势，以及使用场景。</p><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p>使用一个一维数组存储图中顶点信息；使用一个二维数组存储图中边的信息（各顶点间的邻接关系），存储边信息的二维数组称为邻接矩阵。</p><p>顶点数为$n$的图$G=<V,E>$的邻接矩阵<strong>A</strong>是$n \times n$的，将顶点集$G$中的顶点编号是$v_1,v_2,…,v_n$，则：</p><script type="math/tex; mode=display">A[i][j] = \begin{cases}  0, & (v_i,v_j)\ or <v_i,v_j> is\ an\ edge \\  1, & (v_j,v_i)\ or <v_j,v_i> is\ an\ edge \end{cases}</script><p>在带权图，如果顶点$v_i$和$v_i$之间没有边，则$A[i][j]=A[j][i]=\infty$，如果有边，那么$A[i][j]$或者$A[j][i]$的值是边的权值。</p><p>邻接矩阵法存储空间复杂度：$O(n^2)$，其中$n=|V|$。</p><p>缺点：当图是稀疏图时，邻接矩阵法会浪费大量存储空间。</p><h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><p>邻接表法结合了顺序存储和链式存储方法。</p><p>边表：对图$G$中的每个顶点$v_i$建立一个单链表，第$i$个单链表中的结点表示从顶点$v_i$出发的边（对于无向图是和$v_i$关联的边）。边表结点包含两个域，邻接点域（存储和顶点$v_i$邻接的顶点编号），和指向下一条边的边表结点的指针。</p><p>顶点表：指向边表的指针和顶点的数据信息采用顺序存储，称为顶点表。顶点表的顶点结点包含两个域，指向边表的指针域，和保存顶点$v_i$信息的顶点域。</p><p>有向图邻接表法的空间复杂度是$O(|V|+|E|)$，无向图邻接表法的空间复杂度是$O(|V|+2|E|)$。</p><h3 id="邻接矩阵法和邻接表法的优缺点对比"><a href="#邻接矩阵法和邻接表法的优缺点对比" class="headerlink" title="邻接矩阵法和邻接表法的优缺点对比"></a>邻接矩阵法和邻接表法的优缺点对比</h3><ul><li>邻接表法更适合稀疏图的存储。</li><li>邻接表法适合查找某个顶点关联的所有边，相同的操作在邻接矩阵法中需要$O(|V|)$的时间复杂度。</li><li>邻接矩阵法适合判断两个顶点之间是否存在边，操作的时间复杂度是$O(1)$，而在邻接表法中需要遍历顶点的边集。</li><li>在求顶点的度操作中，邻接链表比邻接矩阵法效率更高。</li></ul><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>十字链表是有向图的一种链式存储结构，使用弧结点表示弧（有向图的边），使用顶点结点表示顶点。</p><p>弧结点：<br>|弧尾结点|弧头结点|弧头相同的下一个弧结点的指针|弧尾相同的下一个弧结点的指针|弧的信息|<br>|————|———|———|———|———|<br>|$tail_vertex$|$head_vertex$|$tail_link$|$head_link$|$Info$ |</p><p>顶点结点：<br>| 顶点数据信息 |指向以该顶点为弧头的第一个弧结点| 指向以该顶点为弧尾的第一个弧结点|<br>|————|———|———|<br>|$data$|$first_in_edge$|$first_out_edge$|</p><p>由于有$|V|$个顶点结点，有$|E|$个弧结点，所以空间复杂度是$O(|V|+|E|)$。</p><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>邻接多重表是无向图的一种链式存储结构。每条边都用一个结点表示，每个顶点用一个结点表示。</p><p>边结点：<br>|结点1|下一条依附于结点1的边结点的指针|结点2|下一条依附于结点2的边结点的指针|边的信息|<br>|————|———|———|———|———|<br>|$vertex_1$|$link_1$|$vertex_2$|$link$_2|$Info$ |</p><p>顶点结点：</p><div class="table-container"><table><thead><tr><th>顶点数据信息</th><th>和顶点依附的第一个边结点的指针</th></tr></thead><tbody><tr><td>$data$</td><td>$first_edge$</td></tr></tbody></table></div><p>由于有$|V|$个顶点结点，有$|E|$个边结点，所以空间复杂度是$O(|V|+|E|)$。</p><h3 id="几种存储方法对比"><a href="#几种存储方法对比" class="headerlink" title="几种存储方法对比"></a>几种存储方法对比</h3><div class="table-container"><table><thead><tr><th></th><th>邻接矩阵</th><th>邻接表</th><th>十字链表</th><th>邻接多重表</th></tr></thead><tbody><tr><td>空间复杂度</td><td>$O({\</td><td>V\</td><td>}^2)$</td><td>无向图：$O(\</td><td>V\</td><td>+2\</td><td>E\</td><td>)$；有向图：$O(\</td><td>V\</td><td>+\</td><td>E\</td><td>)$</td><td>$O(\</td><td>V\</td><td>+\</td><td>E\</td><td>)$</td><td>$O(\</td><td>V\</td><td>+\</td><td>E\</td><td>)$</td></tr><tr><td>找给定顶点的邻边</td><td>遍历对应或列的时间复杂度$O(\</td><td>V\</td><td>)$</td><td>找有向图的入度必须遍历整个邻接表</td><td>遍历边结点的链表</td><td>遍历边结点的链表</td></tr><tr><td>删除顶点或边</td><td>删除边很方便，删除顶点需要移动大量数据</td><td>不方便</td><td>方便</td><td>方便</td></tr><tr><td>适用于</td><td>稠密图</td><td>稀疏图</td><td>只能存有向图</td><td>只能存无向图</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的基础</title>
      <link href="/2024/11/09/%E6%A0%91/"/>
      <url>/2024/11/09/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树一种递归的数据结构，是$n(n \geq 0)$个结点的有限集。</p><p>任意一棵非空树应满足：</p><ul><li>有且仅有一个根结点。</li><li>当$n&gt;1$时，其余结点可以分为$m(m&gt;0)$个互不相交的有限集$T_1,T_2,…T_m$，其中每个集合本身又是一棵树并称为根结点的子树。</li></ul><p>树的特点：</p><ul><li>根结点没有前驱，其余结点有且只有一个前驱。</li><li>所有结点都可以有<strong>零个或多个后继</strong>。</li></ul><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul><li>结点的度：一个结点的<strong>孩子个数</strong>称为该结点的度。</li><li>树的度：树中<strong>结点的最大度数</strong>称为树的度。</li><li>分支结点（非终端结点）：度大于0的结点。</li><li>叶结点（终端结点）：度为0的结点。</li><li>结点的层次：从根结点开始定义，根结点为第1层，它的孩子为第2层，以此类推。</li><li>结点的深度：结点所在层次。</li><li>树的深度：树中结点的最大层次。</li><li>有序树和无序树：树中结点的各子树从左到右是有次序的，即左右子树不能交换，称为有序树。</li><li>分支：相邻结点之间的关系。</li><li>路径：树中两个结点之间的分支。<br><em>路径部分有疑惑</em></li><li>路径长度：路径上所经过的边的数量（分支数目）。</li><li>森林：$m(m \geq 0)$棵互不相交的树的集合。<h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2></li><li>树的结点数$n$等于所有结点的度数之和加1。</li><li>度为$m$的树中第$i$层上至多有$m^{i-1}$个结点。</li></ul><p>推导：假设所有结点的度均为$m$，第1层有$m^0$个结点，第2层有$m^1$个，以此类推，第$i$层有$m^{i-1}$个结点。</p><ul><li>高度为$h$的$m$叉树至多有$(m^h-1)(m-1)$个结点。</li><li>度为$m$、具有$n$个结点的树的最小高度为$\log_m (n(m-1)+1)$。</li></ul><p>推导：假设除了叶结点外结点的度均为$m$。可以列出式子，$m^0+m^1+…+m^{h-1}=n$，可以求出$h=\log_m (n(m-1)+1)$。</p><ul><li>度为$m$，具有$n$个结点的树的最大高度$h$为$n-m+1$。</li></ul><p>推导：假设只有一个结点的度为$m$。</p><h2 id="树的存储"><a href="#树的存储" class="headerlink" title="树的存储"></a>树的存储</h2><p>树需要保存的信息有：结点本身的数据信息$data$和结点之间的关系。\<br>和线性表的存储结构一样，树的存储也分为顺序存储结构和链式存储结构。</p><h3 id="多重链表结构"><a href="#多重链表结构" class="headerlink" title="多重链表结构"></a>多重链表结构</h3><h4 id="定长结点的多重链表结构"><a href="#定长结点的多重链表结构" class="headerlink" title="定长结点的多重链表结构"></a>定长结点的多重链表结构</h4><p>设$k$为树的度，每个链结点的构造：<br>| 结点数据信息   | 后继结点1 | 后继结点2 |… …|后继结点k|<br>|————|———|———|———|———|<br>| $data$ | $child_1$ | $child_2$ |… …|$child_k$ |</p><p>缺点：不一定每一个结点的度都是$k$，所以浪费存储空间。</p><h4 id="不定长结点的多重链表结构"><a href="#不定长结点的多重链表结构" class="headerlink" title="不定长结点的多重链表结构"></a>不定长结点的多重链表结构</h4><p>每个链结点的构造：<br>| 结点数据信息 | 结点的度 |后继结点1 | 后继结点2 |… …|后继结点k|<br>|————|———|———|———|———|———|<br>| $data$ |$k$| $child_1$ | $child_2$ |… …|$child_k$ |</p><p>缺点：对树的操作不方便。</p><h3 id="三重链表结构"><a href="#三重链表结构" class="headerlink" title="三重链表结构"></a>三重链表结构</h3><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树在树的基础上，其特点是每个结点<strong>至多只有两棵子树</strong>（即二叉树中不存在度大于2的结点），并且二叉树的树有左右之分，即是有序树。</p><p><em>注意：如果二叉树的某个结点只有一棵子树，也要区分子树是左子树还是右子树。</em></p><p>二叉树和<strong>度为2的有序树</strong>的区别：</p><ul><li>度为2的树至少有3个结点，而二叉树可以为空。</li><li>度为2的有序树的孩子的左右次序是相对另一个孩子而言的，如果某个结点只有一棵子树，无需分辨是左子树还是右子树，但是二叉树需要区分单一后继结点是左子树还是右子树。</li></ul><h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h3><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>一棵高度为$h$的二叉树，且有$2^h-1$个结点的二叉树，即二叉树每层都含有最多的结点，除了叶结点外，所有结点的度均为2。</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>高度为$h$，有$n$个结点的二叉树，当且仅当每个结点都与高度为$h$的满二叉树中编号$1$~$n$的结点一一对应。可以理解为：满二叉树删去最底层最右边的一些结点。</p><p>完全二叉树的特点：</p><ul><li>若$i \leq \lfloor n/2 \rfloor$，则结点$i$为分支节点，否则为叶结点。</li><li>叶结点只可能在最下面两层出现，对于最大层次的叶结点，都依次排列在该层最左边的位置上。</li><li>若有度为$1$的结点最多只有$1$个，且该结点只有左孩子而无右孩子。</li><li>若$n$为奇数，则每个分支结点都有左孩子和右孩子，否则编号最大的分支结点（编号为$n/2$）只有左孩子，没有右孩子。</li></ul><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>树中任意一个结点的左子树和右子树的高度差的绝对值不超过1。</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul><li>非空二叉树的叶结点数等于度为2的结点数加1，即$n_0=n_2+1$。</li></ul><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h4><p>对于一个高度为$h$的二叉树，存储在一个大小为$2^h-1$的一维数组里。结点的存储顺序是假设二叉树是满二叉树按层存储，如果位置上没有结点，则存储0元素。</p><p>缺点：非满二叉树浪费存储空间。</p><h4 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h4><p>链表结点的构造为：<br>| 指向左孩子的指针   | 数据域 | 指向右孩子的指针 |<br>|————|———|———|<br>| $lchild$ | $data$ | $rchild$ |</p><p>可以通过添加父结点的指针变成三叉链表。</p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>按照一定的顺序对二叉树中每一个结点都访问一次(仅访问一次), 得到一个由该二叉树的所有结点组成的序列。\<br>常见的遍历次序有先序(PreOrder)，中序(InOrder)和后序(PostOrder)遍历，其中的“序”指的是根结点在何时被访问。三种遍历算法的时间复杂度均为$O(n)$。</p><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>顺序：访问根结点，先序遍历左子树，先序遍历右子树。</p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>顺序：中序遍历左子树，访问根结点，中序遍历右子树。</p><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>顺序：后序遍历左子树，后序遍历右子树，访问根结点。</p><h4 id="递归算法和非递归算法的转换"><a href="#递归算法和非递归算法的转换" class="headerlink" title="递归算法和非递归算法的转换"></a>递归算法和非递归算法的转换</h4><p>使用逻辑结构<strong>栈</strong>。为什么使用栈呢？因为递归的本质也是用栈保存每一层递归函数的结果。</p><p>中序遍历：</p><ol><li>沿着根的左孩子，依次入栈，直到左孩子为空</li><li>栈顶元素出栈并访问：若其右孩子为空，继续执行<strong>2</strong></li><li>若其右孩子不空，将右子树转执行<strong>1</strong></li></ol><p>前序遍历：</p><ol><li>从根结点开始，<strong>访问元素</strong>，将其入栈，并沿着根的左孩子，依次入栈，直到左孩子为空</li><li>栈顶元素出栈：若其右孩子为空，继续执行<strong>2</strong></li><li>若其右孩子不空，将右子树转执行<strong>1</strong></li></ol><p>后序遍历：<br>&lt;!— </p><ol><li>从根结点开始，将其入栈，并沿着根的左孩子，依次入栈，直到左孩子为空</li><li>—&gt;<br><em><strong>手敲代码实现对二叉树的前序/中序/后序遍历的递归和非递归算法，并计算时间和空间复杂度。</strong></em><h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4>使用逻辑结构<strong>队列</strong>实现树的层次遍历。<h4 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h4>已知前序序列和中序序列：在前序序列中确定根; 到中序序列中分左右。\<br>已知中序序列和后序序列：在后序序列中确定根; 到中序序列中分左右。<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3>线索二叉树是基于二叉树遍历得到的序列的升级后的二叉树。二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。前驱和后继是二叉树遍历得到的序列中的直接前驱和直接后继。</li></ol><p>引入线索二叉树的目的：加速查找结点前驱和后继的速度。</p><p>线索二叉树的构造：利用链结点的空的左指针域存放该结点的直接前驱的地址，空的右指针域存放该结点直接后继的地址；而非空的指针域仍然存放结点的左孩子或右孩子的地址。</p><p>链结点的构造：<br>| 指向左孩子/前驱的指针 | 左标志域 | 数据域 |右标志域| 指向右孩子/后继的指针 |<br>|:———-:|:—-:|:—-:|:——:|:——-:|<br>| $lchild$| $ltag$ | $data$ |$rtag$| $rchild$ |</p><p><em><strong>手敲代码实现前序/中序/后序线索二叉树的构造</strong></em></p><h2 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h2><p>树转换为二叉树：每个结点的左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟。<strong>“左孩子右兄弟”。</strong></p><p>森林转换为二叉树：将森林里的每棵树转换成二叉树；在每棵树的原始根之间连线；以第一棵树的根为轴心顺时针旋转$45^。$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串（串）</title>
      <link href="/2024/11/09/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%B8%B2%EF%BC%89/"/>
      <url>/2024/11/09/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%B8%B2%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串（串）"><a href="#字符串（串）" class="headerlink" title="字符串（串）"></a>字符串（串）</h1><p>串(string)是由零个和多个<strong>字符</strong>组成的有限序列，一般记为：</p><script type="math/tex; mode=display">S='a_1a_2...a_n'(n \geq 0)</script><p>前缀：字符串的前缀指除了最后一个字符之外的所有头部子串（是一个集合）。例如，字符串’abcde’的前缀是{a, ab, abc, abcd}，字符串’a’的前缀是{}。\<br>后缀：字符串的后缀指除了第一个地租之外的所有尾部子串。例如，字符串’abcde’的后缀是{e, de, cde, bcde}，字符串’a’的后缀是{}。\<br>部分匹配值：字符串的前缀和后缀的最长相等前后缀长度。例如，字符串’abcde’的部分匹配值为0，因为不存在前缀和后缀相等的情况。</p><h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><ol><li>定长顺序存储表示</li><li>堆分配存储表示</li><li>块链存储表示：类似于线性表的链式存储结构，每个结点称为块，所以链表称为块链结构。和线性表的链式存储结构不同的是，每个块可以存储多个字符。</li></ol><h2 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h2><p>串的模式匹配：子串的定位操作，它通常求的是子串（substring），也称为模式串，在主串中的位置。</p><h3 id="暴力匹配法"><a href="#暴力匹配法" class="headerlink" title="暴力匹配法"></a>暴力匹配法</h3><p>双重循环，假设主串长度为$n$，模式串长度为$m$，暴力匹配法时间复杂度为$O(mn)$。</p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP算法分为两部分：</p><ol><li>计算模式串$T$的错位部分匹配值数组$next$。</li></ol><ol><li>KMP匹配算法。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法预备知识</title>
      <link href="/2024/11/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/11/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构和算法预备知识"><a href="#数据结构和算法预备知识" class="headerlink" title="数据结构和算法预备知识"></a>数据结构和算法预备知识</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>我们该如何理解数据结构？从哪几个角度串起来数据结构的所有知识。首先数据结构是数据元素+数据元素之间的关系。数据结构可以从三个层面理解，分别是——<strong>逻辑结构</strong>、<strong>存储结构</strong>和<strong>针对数据的操作</strong>。</p><h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><p>逻辑结构，我理解为数据元素之间的逻辑关系，</p><h3 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h3><p>存储结构是指数据结构在计算机中的表示，即数据结构如何在计算机内容中存储。<br><strong>直白一点可以理解为如何在计算机物理内存中定位目标数据元素。存储结构是数据元素的逻辑结构在实际的计算机物理内存中的实现。</strong><br>存储结构主要有：</p><ol><li>顺序存储：顺序存储是在计算机内存中<strong>分配一块连续的存储单元</strong>存储数据结构。逻辑上相邻的数据元素在物理上也相邻。优点是可以实现随机存取，缺点是只能使用相邻的一整块内存单元，容易产生外部碎片。</li><li>链式存储：逻辑上相邻的数据元素在物理上不一定相邻，即在计算机内存中不是连续出现的，采用<strong>指针</strong>表示元素中的逻辑关系。优点是不会产生外部碎片，缺点是指针占内存。</li><li>索引存储：在存储信息的同时，还建立索引表。</li><li>散列存储：根据元素的关键字直接计算出该元素的存储地址，称为哈希(Hash)存储。优点是检索、增加和删除的操作都很快，缺点是哈希函数不好，可能出现元素存<br>储的冲突，消耗时间和空间的开销。</li></ol><p>链式存储、索引存储和散列存储的区别是，实现数据元素关系的方式不同（在计算机内存中定位目标元素的方式不同），链式存储通过指针相连，索引存储通过索引表定位目标元素，散列函数通过数据元素的关键字定位元素的物理位置。</p><p>其实我们在后续学习可以发现，一种逻辑结构可以对应多种存储结构。所以后续学习思路是逻辑结构是大的topics，对应的多种存储结构式分支。</p><p>查找和排序是对数据的操作是大的topics，对应的各种算法使用不同的逻辑结构和存储结构实现。</p><p><strong>Q：在树的章节里，实现同一种操作有递归和非递归两种算法，为什么非递归会优于递归呢？</strong></p><h2 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h2><h3 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h3><p>计算问题：给定<strong>数据输入</strong>，计算满足某种性质<strong>输出</strong>的问题。</p><p>算法的定义：给定计算问题，算法是一系列良定义（定义明确无歧义）的计算步骤（计算机可实现的指令），逐一执行计算步骤即可得预期的输出。</p><h3 id="算法的五个重要特性"><a href="#算法的五个重要特性" class="headerlink" title="算法的五个重要特性"></a>算法的五个重要特性</h3><p>有穷性（算法必须在有限个计算步骤后终止）、确定性（算法无歧义）、可行性、输入和输出</p><h3 id="“好”的算法考虑的目标"><a href="#“好”的算法考虑的目标" class="headerlink" title="“好”的算法考虑的目标"></a>“好”的算法考虑的目标</h3><p>正确性，可读性，高效率和低存储量的需求，鲁棒性（对非法的输入数据做出反应和处理，不会产生莫名其妙的输出）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表、栈、队列和数组</title>
      <link href="/2024/11/09/%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/"/>
      <url>/2024/11/09/%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表、栈、队列和数组"><a href="#线性表、栈、队列和数组" class="headerlink" title="线性表、栈、队列和数组"></a>线性表、栈、队列和数组</h1><p>写在前面：其实这些内容应该写成几篇文章，但由于是秋招复习，我就把这些比较基础的数据结构放到一篇文章里，还有利于我们进行对比记忆！那么我们就开始吧！</p><p>首先，线性表、栈、队列和数组都属于数据的逻辑结构范畴，但是逻辑结构在计算机中的存储和本身逻辑结构无关。一种逻辑结构可以有多种存储结构的实现方法。比如逻辑结构线性表的存储结构有——顺序存储和链式存储。</p><p>其次，这四种逻辑结构的内在逻辑是——线性表是最基础的存在，<strong>栈、队列和数组都是特殊的线性表</strong>。其中，栈和队列是操作受限的线性表，</p><h2 id="线性表-Linear-List"><a href="#线性表-Linear-List" class="headerlink" title="线性表(Linear List)"></a>线性表(Linear List)</h2><p>线性表是具有相同数据类型的$n$个数据元素的有限序列。</p><p>线性表的几个我认为比较重要的特点：</p><ul><li>数据元素个数有限</li><li>数据元素在逻辑上有顺序性</li><li>每个数据元素占有相同大小的存储空间</li></ul><h2 id="线性表的存储结构"><a href="#线性表的存储结构" class="headerlink" title="线性表的存储结构"></a>线性表的存储结构</h2><p>线性表的存储结构分为两种——顺序存储和链式存储。</p><h3 id="线性表的顺序存储"><a href="#线性表的顺序存储" class="headerlink" title="线性表的顺序存储"></a>线性表的顺序存储</h3><p>线性表的顺序存储又称为顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。<strong>实现了逻辑结构和存储结构的统一。</strong></p><p>高级程序设计语言通常用<strong>数组</strong>来描述线性表的顺序存储结构。</p><p>顺序表的优点：</p><ul><li>可以进行随机访问，访问顺序表中的元素时间复杂度为$O(1)$。</li><li>存储密度高，每个结点只存储数据元素（无需存储指针）。</li></ul><p>顺序表的缺点：</p><ul><li>插入和删除需要移动大量元素。插入操作平均移动$n/2$个元素，删除操作平均移动$(n-1)/2$个元素。</li><li>灵活性差，每次都需要分配一段连续的存储空间。</li></ul><h4 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h4><p>重点分析几种基本操作移动结点的平均次数。</p><ol><li>插入操作：如果在顺序表第$0$位置插入元素，需要移动$n$个元素；如果在顺序表的末尾插入元素，需要移动$0$个元素，时间复杂度用$O(1)$表示；所以平均移动次数为$\sum_{i=0}^n p_i(n-i)={n \over 2}$，插入元素算法的时间复杂度为$O(n)$。</li><li>删除操作：如果删除第一个元素，需要移动$n-1$个元素；如果删除末尾元素，需要移动$0$个元素；平均移动元素数量是$\sum_{i=0}^{n-1} p_i(n-i-1)={n-1 \over 2}$。</li><li>按值查找（顺序查找）：如果目标元素是第一个元素，需要比较$1$次，时间复杂度可以表示为$O(1)$；如果目标元素是末尾元素，需要比较$n$次；平均比较次数是$\sum_{i=0}^n p_i(n-i+1)={n+1 \over 2}$。</li></ol><p>顺序表插入、删除和按值查找算法时间复杂度均为$O(n)$。</p><h3 id="线性表的链式存储"><a href="#线性表的链式存储" class="headerlink" title="线性表的链式存储"></a>线性表的链式存储</h3><p>线性表的链式存储又称为<strong>链表</strong>。链表的内容可以分为单链表、双链表、循环链表（循环单链表和循环双链表）和静态链表。</p><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>通过一组任意的存储单元来存储线性表中的数据元素，使用<strong>指针</strong>建立数据元素之间的线性关系。对于每个链表结点，同时保存元素自身信息和一个指向后继数据元素结点的指针。</p><p>通常使用头指针(head)来标识一个单链表，指向单链表的起始地址。需要<strong>讨论head是否为NULL</strong>，如果head==NULL，说明单链表是空的，否则指向单链表的第一个结点。</p><p><strong>单链表的重要操作</strong></p><ol><li>插入结点操作</li></ol><p>插入结点可以分为前插和后插。后插操作的时间复杂度为$O(1)$。前插操作可以转换为后插操作，并且将传统前插操作的时间复杂度$O(n)$降为$O(1)$。</p><p>前插=后插 + 交换待插入结点$<em>s$和目标结点$</em>p$的data域。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后插</span></span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line"><span class="comment">//交换值</span></span><br><span class="line">temp = s-&gt;data;</span><br><span class="line">s-&gt;data = p-&gt;data;</span><br><span class="line">p-&gt;data = temp;</span><br></pre></td></tr></table></figure></p><ol><li>删除结点操作</li></ol><p>删除某个特定结点$<em>p$，如果按照传统操作，需要先找到结点的前驱结点，再进行删除操作，此时时间复杂度为$O(n)$。如果将问题转化为删除$</em>p$的下一个结点，并将下一个结点的data域赋给$*p$，时间复杂度可以将为$O(1)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure></p><ol><li>建立单链表：有头插法和尾插法两种，为了保持数据元素顺序，推荐使用尾插法。</li></ol><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>对于每个链表结点，同时保存元素自身信息、一个指向后继数据元素结点的指针以及一个指向前驱元素结点的指针。</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p><strong>循环单链表</strong>和单链表的区别是，最后一个结点的后继指针不是指向NULL，而是指向链表的第一个结点。</p><p><strong>循环双链表</strong>和双链表的区别是，最后一个结点的后继指针指向第一个结点，并且第一个结点的前驱指针指向最后一个结点。</p><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p>静态链表是使用数组来描述线性表的链式存储结构，静态链表需要一块连续的内存空间保存。对于每一个结点，也有数据域和指针域，指针域是下一个结点在数组中的相对地址。下面这张图可以很轻松地理解静态链表了：</p><!-- ![静态链表](2024-11-09-线性表、栈、队列和数组/静态链表.png) --><img src="/2024/11/09/%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8.png" class="" title="静态链表"><h3 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol><li>存取方式：顺序表可以顺序存取也可以随机存取，但是链表只能顺序存取。</li><li>逻辑结构和物理结构：线性表在逻辑结构和物理结构保持统一，但是链表逻辑结构相邻，物理结构不一定相邻。</li><li>查找、插入和删除：链表的查询算法复杂度均为$O(n)$。无序线性表按值查询时间复杂度为$O(n)$；有序线性表按值查找可以使用折半查找，时间复杂度为$O(\log_2n)$；线性表按序号查找时间复杂度均为$O(1)$。对于插入和删除操作，线性表平均要移动半个表长的元素，链表只需要修改相关结点的指针域即可。</li><li>空间分配：线性表存储密度高（因为不用考虑指针域），但是线性表的规模需要提前确定（因为需要分配连续的空间）。链表在需要添加新的结点时，为新结点申请空间即可，更加灵活。</li></ol><h4 id="如何选择线性表还是链表？"><a href="#如何选择线性表还是链表？" class="headerlink" title="如何选择线性表还是链表？"></a>如何选择线性表还是链表？</h4><p>可以从存储，运算（复杂度），环境的方向进行思考。</p><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h2><p>栈是只允许在一端进行插入或删除操作的线性表。栈有两个新的概念：栈顶(Top)、栈底(Bottom)。</p><p>因为栈的本质是一种操作受限制的线性表，所以栈也有顺序和链式两种存储结构。</p><h3 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h3><p>采用顺序存储的栈称为顺序栈，顺序栈利用一组地址连续的存储单元按照从栈底到栈顶的顺序存在数据元素，同时设一个指针(Top)指示当前栈顶元素的位置。</p><p>初始化，设置栈顶指针$Top=-1$；进栈时，先$Top=Top+1$，再送值到栈顶；出栈时，先取栈顶元素，然后$Top=Top-1$。</p><p>共享栈：让两个顺序栈共享一个一维数组空间。将一个栈底设置为$-1$，另一个栈底设置为$Maxsize$。</p><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><p>采用链式存储的栈称为链栈。</p><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h2><p>队列是只允许在表的一端进行插入，而在表的另一端进行删除的线性表。操作特性采用先进先出的原则，即先入队的元素先出队。</p><p>队有两个新概念，队头(Front)指允许删除的一端，队尾(Rear)指允许插入的一端。（其实这两个可以交换，但我个人偏好这样设置）</p><h3 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h3><p>队列的顺序存储是指分配一块连续的存储空间存放队列中的元素，设队列为$Q$，队首指针为$Q.front$，队尾指针为$Q.rear$。</p><p>初始化，$Q.front=Q.rear=0$；新元素入队：将元素送至队尾，再$Q.rear=Q.rear+1$；元素出队：先取队首元素值，再$Q.front=Q.front+1$。</p><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>顺序队列会存在假溢出的问题，由于$Q.front$和$Q.rear$n不断增长，所以可以使用循环队列解决上述问题。我们将顺序队列想象成一个<strong>环</strong>。循环队列在传统顺序队列基础上，所有操作在计算时需要$\%Maxsize$。</p><p>初始化，$Q.front=Q.rear=0$；新元素入队：将元素送至队尾，再$Q.rear=(Q.rear+1)\%Maxsize$；元素出队：先取队首元素值，再$Q.front=(Q.front+1)\%Maxsize$；计算队列长度$(Q.rear+Maxsize-Q.front)\%Maxsize$。</p><h3 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h3><p>队列的链式表示称为链队列，本质上是一个带有队头指针和队尾指针的单链表。</p><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列是指允许两端都可以进行插入和删除操作的线性表。</p><p><strong><em>个人感觉栈和队列的内容需要配合王道练习题理解。</em></strong></p><h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h2><p>定义：数组是由$n$($n\geq 1$)个相同类型的数据元素构成的有限序列，每个数据元素都是一个数组元素。</p><ul><li>下标：每个元素在n个线性关系中的序号。</li><li>维界：下标的取值范围。</li></ul><p>数组是线性表的推广。一维数组可视为一个线性表；二维数组可视为<strong>其元素是定长数组</strong>的线性表。数组一旦被定义，其维数和维界就不再改变。</p><h3 id="数组的存储结构"><a href="#数组的存储结构" class="headerlink" title="数组的存储结构"></a>数组的存储结构</h3><p>一个数组的所有元素在内存中占有一段连续的存储空间。</p><p>以一维数组$A[0…n-1]$为例，其存储结构关系式为:</p><script type="math/tex; mode=display">LOC(a_i)=LOC(a_0)+i\times L （0 \leq i \lt n）</script><p>其中，$L$是每个数据元素所占的存储单位。</p><h3 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h3><p>目的是节省存储空间，提升性能。</p><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p>主要考察对角矩阵压缩存储的下标对印关系。</p><p>由于对称矩阵上三角区和下三角区元素是一致的，所以会浪费一半存储空间。所以我们只需要存储下三角区和主对角线的元素，即$a_{i,j}(i \geq j)$。我们将$n$阶对接矩阵$A$存放在一维数组$B[n(n+1)/2]$中。</p><p>元素$a_{i,j}$在数组中的下标是$k=1+2+…+(i-1)+j-1={i(i-1)\over 2}+j-1$。</p><p>元素下标之间的对应关系如下：</p><script type="math/tex; mode=display">k = \begin{cases}  {i(i-1) \over 2}+j-1, & i \geq j （下三角区和主对角线元素）\\  {j(j-1) \over 2}+i-1, & i < j （上三角区元素）\end{cases}</script><h4 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h4><p>下三角矩阵是上三角区的所有元素均为同一常量。（上三角矩阵同理）下三角区和主对角线元素按顺序存储，紧接着存储上三角区的常量，所以将$n$阶下三角矩阵$A$压缩存储在$B[n(n+1)/2+1]$。</p><p>下三角矩阵元素下标之间的对应关系为（从$0$开始）：</p><script type="math/tex; mode=display">k = \begin{cases}  {i(i-1) \over 2}+j-1, & i \geq j （下三角区和主对角线元素）\\  {n(n+1) \over 2}, & i < j （上三角区元素）\end{cases}</script><p>上三角矩阵元素下标的对应关系为（从$0$开始）：</p><script type="math/tex; mode=display">k = \begin{cases}  {(i-1)(2n-i+2) \over 2}+j-i, & i \leq j （下三角区和主对角线元素）\\  {n(n+1) \over 2}, & i > j （上三角区元素）\end{cases}</script><h4 id="三对角矩阵"><a href="#三对角矩阵" class="headerlink" title="三对角矩阵"></a>三对角矩阵</h4><p>对角矩阵也称带状矩阵。对$n$阶矩阵$A$中的任意一个元素$a<em>{i,j}$，当$|i-j|&gt;1$时，都有$a</em>{i,j}=0$，则称为三对角矩阵。按照行优先方式存放在数组中，下标$k=2i+j-3$。</p><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p>矩阵中的非零元素的个数$t$，相对于矩阵元素的个数$s$来说非常少，则称为这种矩阵为稀疏矩阵。可以采用<strong>三元组</strong>(行标$i$，列标$j$，值$a_{i,j}$)的形式保存稀疏矩阵。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>个人感觉，应用这部分更加重要，更贴近对计算机的理解以及编程题刷题。</p><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h3><h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><h4 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学预备知识</title>
      <link href="/2024/11/09/%E6%95%B0%E5%AD%A6%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/11/09/%E6%95%B0%E5%AD%A6%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法复杂度分析</title>
      <link href="/2024/11/09/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2024/11/09/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h1><p>这一部分的内容可以说是<strong>最重要</strong>但是我最薄弱的一部分了。重要的原因在于每次面试都会碰到，从大陆找互联网实习面试，到目前在HK很惨淡的找technology for finance实习的面试，到大四卓工保研面试。为什么说我很薄弱呢？因为70%我都是算错或者不会算。</p><p>算法复杂度分析可以分为时间复杂度分析和空间复杂度分析。所有的讨论都基于<strong>通用输入空间/规模(general input space)为n</strong>为前提。</p><p>算法复杂度分析的是最坏的情况。</p><h2 id="算法时间复杂度分析"><a href="#算法时间复杂度分析" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h2><p>一个语句的频度是指该语句在算法中被<strong>重复执行的次数</strong>。</p><p><span style="color: red;">算法中所有语句的频度之和记为$T(n)$，即为算法的时间复杂度。</span></p><p>时间复杂度主要分析$T(n)$的数量级。算法中最深层循环中的语句被称为基本运算。所以我们在计算算法时间复杂度时，只关注最深层循环中的语句执行次数即可。</p><h3 id="渐进分析"><a href="#渐进分析" class="headerlink" title="渐进分析"></a>渐进分析</h3><p>渐近分析是一种分析算法时间复杂度$T(n)$的方式：忽略$T(n)$的系数和低阶项，仅关注高阶项。</p><p>例如，$T(n)=2n^2+3n-4=O(n^2)=\theta (n^2)=\Omega(n^2)$</p><p>有三种渐近分析记号：</p><ul><li>$\theta(g(n))$：渐近紧确界，表示所有满足条件的函数$T(n)$的集合。$\theta(g(n))={T(n): \exist \ c_1,c_2,n_0&gt;0,\ such\ that \ c_1 \times g(n) \leq T(n) \leq c_2 \times g(n) \ for \ all \ n \geq n_0}$。</li><li>$O(g(n))$：渐近上界，表示所有满足条件的函数$T(n)$的集合。$O(g(n))={T(n): \exist \ c,n_0&gt;0,\ such\ that \ 0 \leq T(n) \leq c \times g(n) \ for \ all \ n \geq n_0}$。</li><li>$\Omega(g(n))$：渐近下界，表示所有满足条件的函数$T(n)$的集合。$\Omega(g(n))={T(n): \exist \ c,n_0&gt;0,\ such\ that \ T(n) \geq c \times g(n) \ for \ all \ n \geq n_0}$。</li></ul><p>上述表示方法中，$g(n)$都是一致的，都是<strong>忽略$T(n)$的系数和低阶项，仅关注高阶项</strong>。</p><p>为什么渐近上界$O(g(n))$更常见？</p><p>常见的渐进时间复杂度为（以$ O(g(n)) $为例）：</p><script type="math/tex; mode=display">O(1)<O(\log_2(n))<O(n)<O(n\log_2(n))<O(n^2)<O(n^3)<O(2^n)<O(n!)</script><h3 id="如何计算时间复杂度？"><a href="#如何计算时间复杂度？" class="headerlink" title="如何计算时间复杂度？"></a>如何计算时间复杂度？</h3><p>我认为程序类型可以分为两种：<br>有循环的程序（例如，$for$循环和$while$循环）和无循环的程序。</p><p>第一步：寻找基本操作。</p><h4 id="循环程序"><a href="#循环程序" class="headerlink" title="循环程序"></a>循环程序</h4><p>我们需要根据循环终止条件和循环变量的操作计算时间复杂度（一般是循环变量的操作次数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i=i+<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n) &#123;</span><br><span class="line">    i = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述$for$循环的结构中，循环终止条件判断指的是$i&lt;n$，循环变量的操作指的是$i=i+1$。在$while$循环中，循环终止条件判断指的是$i&lt;n$，循环变量的操作指的是$i=i+1$。</p><p>设基本运算的执行次数为$t$（在$for$和$while$循环中，基本运算都是循环变量的操作）。在每次基本操作中，循环变量$i$都$+1$。所以在t次操作之后，循环变量的值变为$i=t<em>1$，我们再看循环终止条件$i&lt;n$，代入可以得到$i=t</em>1&lt;n$，即$t&lt;n$。</p><p>所以，$\textbf{T(n)=t=O(n)}$。</p><p>再看一个循环变量操作是乘法的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n) &#123;</span><br><span class="line">    i = i*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>设基本操作$i = i*2$的执行次数为$t$，在经历了$t$操作后，循环变量$i=2^t$。根据循环终止条件$i&lt;n$，我们得到式子：$i=2^t&lt;n$，所以，$t&lt;\log_2n$。</p><h4 id="无循环程序"><a href="#无循环程序" class="headerlink" title="无循环程序"></a>无循环程序</h4><p>这一类问题，我们只需要解决递归(recursion)问题即可。<br>递归问题一般使用公式进行递推。例如，求解$T(n)$和下一层更小规模的时间复杂度$T(n-1)$之间的关系。</p><p>我们以最经典的问题使用递归法求斐波那契数列为例子：</p><script type="math/tex; mode=display">F(n) = \begin{cases}  0, & n = 0 \\  1, & n = 1 \\  F(n-1) + F(n-2), & n > 1\end{cases}</script><p>递归问题的原理是逐步缩小输入数据的规模，所以计算递归问题的时间复杂度也可以按照这个思路，计算所有基本语句的执行次数。</p><p>假设原始问题（输入规模为$n$）的时间复杂度为T(n)，根据斐波那契数列公式我们可以知道，$T(n)=1+T(n-1)+T(n-2)$，其中的$1$指的是这一层计算的次数，如果有循环的话，执行次数就会转换为$n$了。接下来，进行下一层的推导，$T(n)=O(1)+(O(1)+T(n-1)+T(n-2))+(O(1)+T(n-2)+T(n-3))$。所以，</p><script type="math/tex; mode=display">T(n)=O(1)+2^1*O(1)+2^2*O(1)+...+2^n*O(1)=(2^n-1)*O(1)=O(2^n)</script><p>递归问题时间复杂度求解还有一个很形象的方法就是递归树法。</p><h3 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span>((i+<span class="number">1</span>)(i+<span class="number">1</span>)&lt;n) &#123;</span><br><span class="line">    i = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述问题是循环程序求解，循环变量是$i$，假设基本语句$i=i+1$的执行次数是$t$，在经历了$t$次运算后，$i=5+t$，根据循环终止条件可获得式子：$(t+6)*(t+6)&lt;n$，所以$t&lt;\sqrt{n}-6=O(\sqrt{n})$。</p><h2 id="算法空间复杂度分析"><a href="#算法空间复杂度分析" class="headerlink" title="算法空间复杂度分析"></a>算法空间复杂度分析</h2><p>算法空间复杂度$S(n)$定义为该算法所需要的<strong>辅助存储空间</strong>（默认输入规模为$n$），例如几个与输入数据规模$n$相同的辅助数组的时空间复杂度为$O(n)$、辅助HashMap等。</p><p>空间复杂度的计算还是比较容易的，主要是计算最大辅助存储空间即可，例如二维数组$int[n][n]$的空间复杂度$S(n)$为$O(n^2)$。根据渐近分析的定义，我们只选择最高阶项即可。</p><h3 id="递归问题的空间复杂度分析"><a href="#递归问题的空间复杂度分析" class="headerlink" title="递归问题的空间复杂度分析"></a>递归问题的空间复杂度分析</h3><p>递归问题的算法复杂度分析涉及到程序运行原理，每进行一层的递归，都需要程序运行栈提供$O(1)$的辅助存储位置保存这一层的结果，直到递归程序到达底端，此时程序运行栈中保存的数据数量最多，只要计算这个时候占了多少存储空间即可。在递归树中，空间复杂度为递归树的层高。</p><p><em>参考文献：北航计算机专业《算法设计与分析》课程、王道数据结构、HKU ARIN7001 PartIII</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Resume related Questions</title>
      <link href="/2024/11/07/Resume-related-Questions/"/>
      <url>/2024/11/07/Resume-related-Questions/</url>
      
        <content type="html"><![CDATA[<h1 id="简历相关问题"><a href="#简历相关问题" class="headerlink" title="简历相关问题"></a>简历相关问题</h1><p>写在前面：因为我打算同时看看<del>香港</del>和大陆的工作机会，所以我的简历相关的问题都是双语形式的。</p><p>我认为简历相关的问题分为三个部分：</p><ul><li>自我介绍(self-introduction)</li><li>实习经历(internship experience)</li><li>项目经历(project experience)</li></ul><h2 id="自我介绍-self-introduction"><a href="#自我介绍-self-introduction" class="headerlink" title="自我介绍(self-introduction)"></a>自我介绍(self-introduction)</h2><p>尊敬的面试官，早上/中午/下午/晚上好，非常感谢贵公司给予我这次面试机会。我叫段桑妮，我将从四个方面介绍自己。</p><p>Good afternoon/ morning. Thank you for giving me the opportunity to be interviewed for this position today. My name is Duan Sangni. You can also call me Sunny. That is my English name. I am going to introduce myself from 4 aspects.</p><h4 id="Educational-Background"><a href="#Educational-Background" class="headerlink" title="Educational Background"></a>Educational Background</h4><p>我本科毕业于北京航空航天大学计算机学院，我的专业是计算机科学与技术。目前是香港大学的人工智能硕士。<br>本科和研究生阶段的课程学习使我拥有较强的数学背景以及对计算机科学和人工智能专业都有扎实的理解。</p><p>First of all, in terms of educational background, I completed my bachelor’s degree in computer science and technology in Beihang University. I am currently a postgraduate student at the University of Hong Kong and my major is artificial intelligence. My undergraduate and postgraduate studies have given me a strong mathematical background and a solid understanding of computer science and artificial intelligence.</p><h4 id="Technical-Background-Internship-and-Project"><a href="#Technical-Background-Internship-and-Project" class="headerlink" title="Technical Background: Internship and Project"></a>Technical Background: Internship and Project</h4><p>第二，在技术能力和x相关经验方面，我有多次实习和项目经历，曾在润晖资产管理公司（金融公司）担任数据开发/分析实习生，在滴滴出行科技公司担任后端开发实习生。</p><p>同时，我独立完成了计算机视觉项目——基于溯源-对抗保护水印的深度伪造防御方法研究。我还参与了一个大型软件工程项目——面向企业技术需求的专家对接服务平台。这些技术经历都强化了我在数据分析、软件开发和人工智能方面的硬实力。</p><p>Second, in terms of technical skills and experience, I have several internships and project experiences. I worked as a data development/analysis intern in Cephei Capital(financial company) and as a back-end development intern in Didi Chuxing Technology Company. </p><p>At the same time, I independently completed the computer vision project - Face Deep Forgery Defense Method Based on Traceable-Adversarial Watermark Protection. I also participated in a large software engineering project - Expert Matching Service Platform for Enterprise Technical Needs. These technical experiences have strengthened my hard skills in data analysis, software development and AI.</p><h4 id="Why-position-Why-me"><a href="#Why-position-Why-me" class="headerlink" title="Why position? Why me?"></a>Why position? Why me?</h4><p>第三点，我今天面试的岗位是[Infrastructure Tool Development Intern]我会讲讲我为什么选择这个职位以及为什么我觉得自己适合这个职位。</p><p>编程语言是工作的基础，我掌握Python、java、C/C++、SQL等语言，并且通过前端开发经验，我熟悉JavaScript、CSS和HTML。</p><p>Thirdly, since my interview today is for the position of <strong>[Engineering (Quantitative Strategists) Summer Analyst position]</strong>, I will talk about why I chose this position and why I feel I am suitable for it. </p><p>Programming language is the basis of work, I master Python, java, C/C++, SQL and other languages, and through front-end development experience, I am familiar with JavaScript, CSS and HTML.</p><p>第二点，本岗位需要具备软件开发经验。除了课内学习中的编程大作业或者参加比赛的project外，我在滴滴实习的岗位也是做后端开发的，并且我也有一定的架构设计和核心功能开发等工作的经验。我当时所在的小组是做核心模块乘客推荐引擎的，并且我独立开发了报警阻断模块。滴滴实习的过程中，我也接触了一些关于平台稳定性维护的东西。在软件工程课程中，我和团队一起开发了面向企业技术需求的专家对接服务平台。我负责开发小程序APP端和网页端的前端开发，以及AI推荐模块的模型训练。SciBERT模型。其中使用的前端框架是Vue3，后端框架flask。</p><p>I once worked as an intern in a financial investment company, and I was attracted by <strong>technology for finance</strong>. Therefore, I am very longing for this internship. I think this job is very consistent with my future career direction, and I can gain the skills I want. </p><p>I am particularly drawn to this role because it offers the unique opportunity to combine advanced mathematics, programming, and financial engineering in a real-world environment. The position’s focus on developing quantitative models for prediction, pricing, and trading automation aligns seamlessly with my passion for problem-solving and my technical strengths in software development, data analysis, and machine learning. I am excited by the chance to tackle complex analytical challenges that will directly impact business decisions and performance in global financial markets.</p><p>Furthermore, Goldman Sachs’s commitment to innovation and to pushing the limits of digital possibilities resonates with my professional values. I am highly motivated to be a part of a team that proactively addresses market challenges and drives financial transformation.  My technical foundation, passion for finance, and eagerness to learn new quantitative methods uniquely position me to contribute effectively in this fast-paced and collaborative role.</p><p>最后就是我性格开朗外向，与人交流和沟通的能力较强。在团队合作中，我具备良好的团队意识和沟通能力，能够脚踏实地地服从安排，并虚心接受他人的批评与指导。并且我对我的学习能力和自我驱动能力有一定的信心，我将继续保持积极向上的学习态度，努力学习提高自己的专业水平和综合素质。感谢您的倾听！</p><p>Finally, I am outgoing girl and have a strong ability to communicate with others. Meanwhile, I have a good sense of teamwork, can obey the arrangement down-to-earth, and humbly accept the criticism and guidance of others. In addition, I am confident of my learning and self-driving ability. I will continue to maintain a positive learning attitude and work hard to improve my professional level and comprehensive quality. </p><h2 id="Project-Experience"><a href="#Project-Experience" class="headerlink" title="Project Experience"></a>Project Experience</h2><h3 id="AI-Face-Deep-Forgery-Defense-Method-Based-on-Traceable-Adversarial-Watermark-Protection"><a href="#AI-Face-Deep-Forgery-Defense-Method-Based-on-Traceable-Adversarial-Watermark-Protection" class="headerlink" title="AI: Face Deep Forgery Defense Method Based on Traceable-Adversarial Watermark Protection"></a>AI: Face Deep Forgery Defense Method Based on Traceable-Adversarial Watermark Protection</h3><p>中文名：基于溯源-对抗保护水印的<br>人脸深度伪造防御方法研究</p><p>项目领域和技术栈：本项目属于人工智能中的计算机视觉领域。在实现过程中，我使用了python语言和pytorch深度学习框架。</p><p>This project belongs to the field of <strong>computer vision in artificial intelligence</strong>. For the technology stack, I used the <strong>Python</strong> language and <strong>Pytorch</strong> deep learning framework.</p><p>研究背景与意义：我们生活中有一种技术叫深度合成技术。这种技术可以生成以假乱真的图像、视频和音频等合成内容。深度合成技术在不同领域都有创造性应用。例如，著名电影《速度与激情7》利用这种技术“复活”了保罗·沃克。当深度合成技术被恶意滥用时，正向的合成技术就变成了负面的伪造手段。深度伪造技术可能会带来影响国际关系、新闻舆论、侵犯公众利益等危害，所以对深度伪造技术的防御就十分重要。</p><p>For the research background: There is a technology in our daily life called deep synthesis technology. This technology can produce fake images, video and audio and other composite content. Deep synthesis technology has creative applications in different fields. For example, the famous film Fast &amp; Furious 7 used this technology to “bring back” Paul Walker. When deep synthesis technology is maliciously abused, positive synthesis technology becomes a negative means of counterfeiting. Deep forgery technology may bring harm such as affecting international relations, news and public opinion, so the defense of deep forgery technology is very important.</p><p>我的项目就是基于这个背景，提出一种溯源-对抗保护水印，实现嵌入一个水印同时具备溯源和针对深度伪造技术的对抗保护两个功能。溯源功能是通过提取人脸图像中的水印从而判断这张图像的主人。对抗保护功能可以在深度伪造技术对图像恶意篡改时扰乱图像的生成，主要表现为生成失真扭曲的篡改图像。</p><p>My project is based on this background. I proposes a Traceable-Adversarial Watermark, which can embed a watermark with both traceability and adversarial protection against deep forgery technology. Totally two functions. The traceability function is to determine the owner of the image by extracting the watermark in the face image. The adversarial protection function can disturb the image generation when the deep forgery technology maliciously modifies the image. As a result, it produces distorted images.</p><p>技术实现：模型架构包含水印嵌入编码器、水印提取解码器、水印鲁棒性增强模块和深度伪造对抗性约束模块。编码器用于将水印图像嵌入到原始人脸图像中生成嵌入水印的重建图像。解码器用于从图像中提取水印。水印鲁棒性增强模块用于提高水印的鲁棒性，在遇到高斯模糊、压缩等图像操作时，水印仍然可以稳定保留在图像中。最后的深度伪造对抗性约束模块是为了给图像添加对抗和扰乱深度伪造技术的能力。</p><p>For the Technical implementation, The model architecture includes a watermark encoder, a watermark decoder, a watermark robustness enhancement module and an adversarial learning module. </p><p>The encoder is used to embed the watermark image into the original face image to generate the reconstructed image that is identical to the original image. The decoder is used to extract the watermark from the image. The watermark robustness enhancement module is used to improve the robustness of the watermark, and the watermark can still be stably retained in the image when meeting image operations such as Gaussian blur and compression. The final adversarial learning module is designed to add the ability to counter and disrupt deep forge techniques to images.</p><h2 id="Internship-Experience"><a href="#Internship-Experience" class="headerlink" title="Internship Experience"></a>Internship Experience</h2><p>我有两段技术实习，一段是在滴滴出行。滴滴出行是国内一个大型的互联网科技公司，它的业务是关于网约车的。我所在的部门是公司最核心的乘客推荐引擎开发功能。我的职务是后端开发实习生。</p><p>我的实习工作可以分为三部分：独立开发报警阻断模块、协助mentor完成日常平台开发需求和参与调研和开发新业务。</p><p>I had two technical internships, one in Didi Chuxing. Didi Chuxing is a large Internet technology company in China Mainland, and its business is about ride-hailing. My department is the company’s core passenger recommendation engine. My position is back-end development intern.</p><p>My internship can be divided into three parts: independently developing alarm blocking module, assisting mentor in completing daily platform development requirements, and participating in new business development.</p><p>我着重描述我的独自开发经历。<br>I will concentrate on my independent development experience.<br>The company’s alerting platform was overwhelmed by excessive alerts during extreme conditions, such as heavy rain or snow, which have caused inefficiencies and overwhelming the system.<br>I developed an alert-blocking module using Golang and Redis to handle this situation. </p><p>My goal was to ensure that this module effectively filtered out unnecessary notifications during emergencies. I designed the module to allow users to customize parameters such as city, alarm type, and blocking duration.<br>I took the initiative to develop the alert-blocking module using Golang and Redis, which consisted of three main components: the user interface, the alerting platform, and the module itself. The user interface interacted with the module’s API to set alerts and parameters for blocking. The alerting platform utilized the module’s API to determine whether alerts should be blocked, while the module regularly sent users updates on currently blocked alerts.</p><p>In this project, I experienced the whole process from module design, implementation and launch, which not only improved my programming and software development ability, but also improved my team cooperation and problem solving ability.</p><p>The other internship is in a financial company and my role was data development&amp;analysis intern. </p><p>In this internship, I mainly used python programming language, MySQL and SQL Server to deal with database and data analysis, and smart-BI to generate the final data analysis risk control reports.</p><ul><li><p>I Implemented data interaction among third-party software, company databases, and display applications, enhancing data<br>development efficiency by at least 50%; I performed data analysis and created custom visualizations by using Smart-BI.</p></li><li><p>In one task, I Managed 13 custom Barra reports for predictive indicators (beta, tracking error, etc.), completing risk and factor attribution.<br>Then I automated regular report processing and imported into the company database using Python and Barra Portfolio Manager’s API. I employed MySQL for data cleaning and analysis, integrating charts in SmartBI for company’s quarterly risk reports</p></li><li><p>In another task—IMA Custom Index: I Coordinated FTP and SQL Server using raw files from the index company to compile custom indices.</p></li></ul><p>This internship gives me a new understanding of my future life plan, which is technology for finance. So I applied for the engineering position in Goldman Sachs.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Behavior Questions</title>
      <link href="/2024/11/07/Behavior-Questions/"/>
      <url>/2024/11/07/Behavior-Questions/</url>
      
        <content type="html"><![CDATA[<h1 id="Behavior-Questions"><a href="#Behavior-Questions" class="headerlink" title="Behavior Questions"></a>Behavior Questions</h1><h3 id="Why-Company-Why-Program"><a href="#Why-Company-Why-Program" class="headerlink" title="Why Company? Why Program?"></a>Why Company? Why Program?</h3><!-- #### Why Company?Goldman Sachs has an unparalleled reputation as a leader in global finance, known for its commitment to innovation, excellence, and impact in the industry. The firm's dedication to pushing the limits of financial technology and exploring new possibilities aligns perfectly with my career goals. Working here would provide me with the opportunity to learn from some of the brightest minds in finance and technology, allowing me to develop skills and insights that are unique to an institution of this caliber. I am particularly drawn to Goldman Sachs because of its culture of collaboration, its focus on cutting-edge solutions, and its influence on global markets—qualities that inspire me to contribute my technical skills to drive meaningful impact.I appreciate the culture and values of Goldman Sachs. The culture of Goldman Sachs is defined by our people’s commitment to delivering the best service to our clients through collaboration, innovation, and a relentless pursuit of excellence. Values: Partnership, Excellence, integrity and Client Service. These are very much in line with my personal values.#### Why this position?Because of my undergraduate and postgraduate majors, so I chose to apply for the engineering position.The Quantitative Strategist role is an ideal fit for my background, technical skills, and career aspirations. This position offers the unique opportunity to apply advanced mathematics, programming, and financial engineering to solve complex challenges in a dynamic, real-world environment. I am excited to develop quantitative models for prediction, pricing, and trading automation, as these areas align closely with my technical strengths and passion for using data-driven insights to drive business decisions.Moreover, this role’s focus on high-impact, analytical problem-solving is exactly what I am looking for in my career. I am eager to contribute my skills in data analysis, software development, and machine learning, while also learning from Goldman Sachs’ experts who prioritize excellence and innovation. This position will allow me to grow professionally and make significant contributions to Goldman Sachs, its clients, and its mission to deliver exceptional value. -->]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fundamentals of Probability and Statistics II</title>
      <link href="/2024/11/07/Fundamentals-of-Probability-and-Statistics-II/"/>
      <url>/2024/11/07/Fundamentals-of-Probability-and-Statistics-II/</url>
      
        <content type="html"><![CDATA[<h1 id="Fundamentals-of-Probability-and-Statistics-II"><a href="#Fundamentals-of-Probability-and-Statistics-II" class="headerlink" title="Fundamentals of Probability and Statistics II"></a>Fundamentals of Probability and Statistics II</h1><h1 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h1><p>Random Variable: 随机变量本质上是一个函数，这个函数将样本空间的每个基本事件映射成为一个实数。</p><p>有三种随机变量：</p><ul><li>Discrete(包含两个特殊类型Propositional or Boolean)</li><li>Continuous</li><li>mixed</li></ul><p>我们通常使用大写字母(例如$X,Y$)表示随机变量，小写字母(例如$x,y$)表示随机变量的取值。例如，$X=x$中$X$是随机变量，$x$是随机变量可能取到的某个值。</p><p>随机变量根据类别展开会涉及到几个部分：</p><ul><li>probability mass function(pmf) / probability density function(pdf)：前者针对离散型随机变量，后者针对连续型随机变量。</li><li>cumulative distribution function：也称为分布函数。</li></ul><h2 id="离散-Discrete-随机变量"><a href="#离散-Discrete-随机变量" class="headerlink" title="离散(Discrete)随机变量"></a>离散(Discrete)随机变量</h2><h1 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h1><h2 id="联合概率分布-Joint-Probability-Distribution"><a href="#联合概率分布-Joint-Probability-Distribution" class="headerlink" title="联合概率分布(Joint Probability Distribution)"></a>联合概率分布(Joint Probability Distribution)</h2><h2 id="边缘概率分布-Marginal-Probability-Distribution"><a href="#边缘概率分布-Marginal-Probability-Distribution" class="headerlink" title="边缘概率分布(Marginal Probability Distribution)"></a>边缘概率分布(Marginal Probability Distribution)</h2><h2 id="条件概率分布-Conditional-Probability-Distribution"><a href="#条件概率分布-Conditional-Probability-Distribution" class="headerlink" title="条件概率分布(Conditional Probability Distribution)"></a>条件概率分布(Conditional Probability Distribution)</h2><h2 id="随机变量独立性在概率分布中的体现"><a href="#随机变量独立性在概率分布中的体现" class="headerlink" title="随机变量独立性在概率分布中的体现"></a>随机变量独立性在概率分布中的体现</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 数学基础 </tag>
            
            <tag> HKU ARIN7001 </tag>
            
            <tag> HKU ARIN7101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown &amp; Latex 使用详解</title>
      <link href="/2024/11/07/Markdown-Latex-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/11/07/Markdown-Latex-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-amp-Latex-使用详解"><a href="#Markdown-amp-Latex-使用详解" class="headerlink" title="Markdown &amp; Latex 使用详解"></a>Markdown &amp; Latex 使用详解</h1><p>由于我一直在使用这两个工具，但是大多数时候都现用现查，所以打算自己整理一个使用文档。为了让我不混淆这两种语法，我将整理成相同点和不同点的形式。我个人感觉两种语言的语法大多数情况下都是类似的。（不然我也不会一直混淆www）</p><p>此文档会随时更新。</p><p>Markdown:<br>Latex:  </p><h2 id="标题篇"><a href="#标题篇" class="headerlink" title="标题篇"></a>标题篇</h2><h3 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h3><p>在markdown语法中，标题使用#表示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br></pre></td></tr></table></figure></p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h3 id="latex"><a href="#latex" class="headerlink" title="latex"></a>latex</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\section&#123;&#125;</span><br><span class="line">\subsection&#123;&#125;</span><br><span class="line">\subsubsection&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>加粗：latex直接使用\textbf{}对文本进行加粗。</p><p>markdown的普通文本加粗方式是采用一对**，在行内公式或者整行公式中，和latex一样使用\textbf{}加粗。</p><h2 id="代码篇"><a href="#代码篇" class="headerlink" title="代码篇"></a>代码篇</h2><p>代码分为代码行和代码块。</p><h3 id="markdown-1"><a href="#markdown-1" class="headerlink" title="markdown"></a>markdown</h3><p>行内代码以两个顿号 ` 隔开，即 `write down your code `。 </p><p>块级代码则以一组```的形式表示，在两组三个顿号之间的内容是代码块的内容。编程语言标注在第一组顿号之后。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"helloworld"</span>)</span><br><span class="line"><span class="comment">// ```代码语言</span></span><br><span class="line"><span class="comment">//    代码块</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 表格</span><br><span class="line">在Markdown中，可以使用竖线$(|)$和短横线$(-)$来创建表格。以下是一个简单的示例：</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>姓名</th><th>年龄</th><th>城市</th></tr></thead><tbody><tr><td>张三</td><td>25</td><td>北京</td></tr><tr><td>李四</td><td>30</td><td>上海</td></tr><tr><td>王五</td><td>28</td><td>广州</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">| 姓名   | 年龄 | 城市   |</span><br><span class="line">|--------|------|--------|</span><br><span class="line">| 张三   | 25   | 北京   |</span><br><span class="line">| 李四   | 30   | 上海   |</span><br><span class="line">| 王五   | 28   | 广州   |</span><br><span class="line"></span><br><span class="line">### 表格对齐</span><br><span class="line">你还可以控制列的对齐方式，使用冒号$(:)$来指定对齐：</span><br><span class="line"></span><br><span class="line">左对齐：| :--- \</span><br><span class="line">右对齐：| ---: \</span><br><span class="line">中间对齐：| :---: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 公式篇</span><br><span class="line"></span><br><span class="line">公式也可以分为行内公式、整行公式和多行公式。</span><br><span class="line"></span><br><span class="line">行内公式的表示语法是使用一组$表示。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;markdown</span><br><span class="line">$ write down your furmula here$</span><br></pre></td></tr></table></figure><p>在markdown中公式的表示语法是使用 $$ write down your formula $$。</p><p>在latex中，我们使用以下形式表示公式：</p><p>如何实现条件多行公式呢？</p><script type="math/tex; mode=display">F(n) = \begin{cases}  0, & n = 0 \\  1, & n = 1 \\  F(n-1) + F(n-2), & n > 1\end{cases}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">F(n) &#x3D; \begin&#123;cases&#125;</span><br><span class="line">  0, &amp; n &#x3D; 0 \\</span><br><span class="line">  1, &amp; n &#x3D; 1 \\</span><br><span class="line">  F(n-1) + F(n-2), &amp; n &gt; 1</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="运算符篇"><a href="#运算符篇" class="headerlink" title="运算符篇"></a>运算符篇</h2><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>在markdown中，需要使用到上下标的内容需要放在一对$$内，其中上标使用\^符号，下标使用_符号，如果上下标内容不止一个字符，使用{}括起来。也可以同时使用上下标，例如$U^n_{i=1}$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\\上标</span><br><span class="line">$X^&#123;x&#125;$</span><br><span class="line">$X^&#123;xx&#125;$</span><br><span class="line">\\下标</span><br><span class="line">$X_&#123;x&#125;$</span><br><span class="line">$X_&#123;xx&#125;$</span><br><span class="line">\\上标 + 下标</span><br><span class="line">$X^n_&#123;i=<span class="number">1</span>&#125;$</span><br></pre></td></tr></table></figure><h3 id="上-下划线-删除线"><a href="#上-下划线-删除线" class="headerlink" title="上/下划线/删除线"></a>上/下划线/删除线</h3><p>$\overline{X}$：使用\overline{}语法，并使用$$括起来。</p><p>$\underline{X}$：使用\underline{}语法，并使用$$括起来。</p><p><del>X</del>：使用一对~~括起来需要加删除线的内容。</p><p>$\tilde{X}$：使用\tilde{X}的语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$\overline&#123;X&#125;$</span><br><span class="line">$\underline&#123;X&#125;$</span><br><span class="line">~~X~~</span><br><span class="line">$\tilde&#123;X&#125;$</span><br></pre></td></tr></table></figure><h3 id="判断符号"><a href="#判断符号" class="headerlink" title="判断符号"></a>判断符号</h3><script type="math/tex; mode=display">= \neq \lt \gt \leq \geq \nleq \ngeq \approx \not\approx \equiv \not\equiv</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$&#x3D; \neq \lt \gt \leq \geq \nleq \ngeq \approx \not\approx \equiv \not\equiv$$</span><br></pre></td></tr></table></figure><h3 id="根号"><a href="#根号" class="headerlink" title="根号"></a>根号</h3><p>使用 \sqrt{} 来表示平方根，即$\sqrt{n}$，使用 \sqrt[n]{} 来表示$n$次根，即$\sqrt[n]{n}$。</p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>$\times$：使用\times表示乘法符号</p><h3 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h3><p>$\frac{molecule}{denominator}$：有两种分式表示方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\frac&#123;molecule&#125;&#123;denominator&#125;$</span><br><span class="line">$&#123;molecule \over denominator&#125;$</span><br></pre></td></tr></table></figure><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>$\sum\ \sum_X^X X\ \sum_X^{\infty} X$：使用符号\sum和上下标表示法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\sum\ \sum_X^X X\ \sum_X^&#123;\infty&#125; X$</span><br></pre></td></tr></table></figure></p><h3 id="求积"><a href="#求积" class="headerlink" title="求积"></a>求积</h3><p>$\prod\ \Pi\ \prod_X^X X\ \prod_X^{\infty} X$：使用符号\prod和上下标表示法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\prod\ \Pi\ \prod_X^X X\ \prod_X^&#123;\infty&#125; X$</span><br></pre></td></tr></table></figure></p><h3 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h3><p>$\nabla$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\nabla$</span><br></pre></td></tr></table></figure></p><h3 id="绝对值符号"><a href="#绝对值符号" class="headerlink" title="绝对值符号"></a>绝对值符号</h3><p>$| |$</p><h3 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h3><p>$\lfloor x \rfloor$：向下取整符号使用一对\lfloor表示。</p><p>$\lceil x \rceil$：向上取整符号使用一对\rceil表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\lfloor x \rfloor$</span><br><span class="line">$\lceil x \rceil$</span><br></pre></td></tr></table></figure></p><h3 id="对数运算"><a href="#对数运算" class="headerlink" title="对数运算"></a>对数运算</h3><p>$\log_b(x)$: 使用符号\log_b(x)表示以 b 为底的对数。</p><h3 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h3><script type="math/tex; mode=display">\in \notin</script><script type="math/tex; mode=display">\subset \subseteq \not\subset \not\subseteq \supset \supseteq \not\supset \not\supseteq</script><script type="math/tex; mode=display">\cup \cap \emptyset</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$\in \notin $$</span><br><span class="line">$$\subset \subseteq \not\subset \not\subseteq $$</span><br><span class="line">$$\supset \supseteq \not\supset \not\supseteq $$</span><br><span class="line">$$\cup$$ \\并集</span><br><span class="line">$$\cap$$ \\交集</span><br><span class="line">$$\emptyset$$ \\空集</span><br></pre></td></tr></table></figure><h3 id="最大化最小化符号"><a href="#最大化最小化符号" class="headerlink" title="最大化最小化符号"></a>最大化最小化符号</h3><p>$ \min_{x} f(x) $<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \min_&#123;x&#125; f(x) $</span><br></pre></td></tr></table></figure></p><h3 id="矩阵符号"><a href="#矩阵符号" class="headerlink" title="矩阵符号"></a>矩阵符号</h3><p>矩阵转置：$\mathbf{X}^\mathrm{T}$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\mathbf&#123;X&#125;^\mathrm&#123;T&#125;$</span><br></pre></td></tr></table></figure></p><h2 id="特殊字母篇"><a href="#特殊字母篇" class="headerlink" title="特殊字母篇"></a>特殊字母篇</h2><h3 id="需要添加转义字符的字符"><a href="#需要添加转义字符的字符" class="headerlink" title="需要添加转义字符的字符"></a>需要添加转义字符的字符</h3><p>在markdown中，有一些特殊的字符，我们需要添加转移字符\，目前遇到的有：$, {}, *.<br>添加转义字符的目的是，不使用字符本身的特殊作用，只显示字符本身。</p><p>字母和数字以一组$的形式隔开。例如，$\Omega$的源码是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\Omega$</span><br></pre></td></tr></table></figure><br>字母的表示形式还是很容易的，所以我们需要记忆的是各种字母在markdown中怎么写。</p><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><p>$ \Omega \ \omega \ \Theta \ \theta \ \eta \rho$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \Omega \ \omega \ \Theta \ \theta \ \eta \rho $</span><br></pre></td></tr></table></figure></p><h3 id="无穷字符"><a href="#无穷字符" class="headerlink" title="无穷字符"></a>无穷字符</h3><p>$ \infty +\infty -\infty$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ \infty $ 无穷符号</span><br><span class="line">$ +\infty $ 正无穷符号</span><br><span class="line">$ -\infty $ 负无穷符号</span><br></pre></td></tr></table></figure></p><h2 id="插入图像"><a href="#插入图像" class="headerlink" title="插入图像"></a>插入图像</h2><p>在md文件中插入图片的语法为![]()。</p><p>其中方括号是图片描述，圆括号是图片路径。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Fundamentals of Probability and Statistics I</title>
      <link href="/2024/11/06/Fundamentals-of-Probability-and-Statistics/"/>
      <url>/2024/11/06/Fundamentals-of-Probability-and-Statistics/</url>
      
        <content type="html"><![CDATA[<h1 id="Fundamentals-of-Probability-and-Statistics-I"><a href="#Fundamentals-of-Probability-and-Statistics-I" class="headerlink" title="Fundamentals of Probability and Statistics I"></a>Fundamentals of Probability and Statistics I</h1><p>本篇文章的目的是整理在<strong>HKU AI program里面ARIN7001课程的part II</strong>，<strong>ARIN7101课程的基础知识</strong>以及对<strong>考研数学概率论</strong>部分基础知识的一些整理。由于HKU课程是全英文教学的，所以我的文章有关知识部分基本上是双语的。</p><p>概率和统计实际上是两个不同的概念。概率是预测<strong>未来事件</strong>发生的可能性；统计包含了对<strong>过去事件</strong>频率的分析，从数据出发，研究已发生事件的属性和规律。这就回答了我很早以前困惑的问题，考研的概率论更多的是频率预测概率的内容，statistics一上来就是贝叶斯。当然，概率和统计是有一部分相同的基础知识部分，每门课都讲了一遍。</p><p>Probability: predict the likelihood of the future events.<br>Statistics: analyze the frequency of past events.</p><h2 id="Sets-and-Events"><a href="#Sets-and-Events" class="headerlink" title="Sets and Events"></a>Sets and Events</h2><p><strong>Sample Space</strong>: 样本空间，通常用$\Omega$表示。随机试验中的每一个可能的结果（强调原子性，即不可再分）称为样本点，记为$\omega$。样本点的全体组成的集合称为样本空间。$\Omega = { \omega }$。</p><p><strong>Atomic Event</strong>: 由一个样本点构成的事件称为基本事件。</p><p><strong>Event</strong>: 随机事件A是由若干个基本事件组成，A是$\Omega$的子集。</p><p>Union: 并集。</p><p>Intersection: 交集。</p><p>Disjoint(mutually exclusive): 中文翻译为不相交，互斥。即$E_i \cap E_j = \emptyset$</p><p>Partition: 完备事件组。有限个事件${E_1, E_2,…,E_n}$满足互斥和$E_1 \cup E_2 \cup … \cup E_n = \Omega$，则称构成一个完备事件组。</p><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><p>概率是对随机事件A发生可能性大小的度量，记为$P(A)$。</p><ul><li>对于一个随机事件$A \subset \Omega$, $P(A) \in [0,1]$</li><li>$P(\emptyset) = 0$, $P(\Omega)=1$.</li><li>$P(A) + P(A^c) = 1$.</li><li>对于互斥事件(mutually exclusive) $E<em>1, E_2,…, E_n$，<br>$P(U^n</em>{i=1} E<em>i) = \sum^n</em>{i=1} P(E_i)$.</li><li>对于完备事件组(partition) $E<em>1, E_2,…, E_n$，$P(\cup^n</em>{i=1} E_i) = P(\Omega) = 1$.</li></ul><h2 id="常见概率公式"><a href="#常见概率公式" class="headerlink" title="常见概率公式"></a>常见概率公式</h2><h3 id="加法公式"><a href="#加法公式" class="headerlink" title="加法公式"></a>加法公式</h3><p>对于两个任意事件$E_1$和$E_2$，有<br>$P(E_1\cup E_2) = P(E_1) + P(E_2) - P(E_1 \cap E_2)$.</p><p>对于三个任意事件$E_1$, $E_2$和$E_3$，有</p><p>$P(E_1\cup E_2\cup E_3) = P(E_1) + P(E_2) + P(E_3) - P(E_1 \cap E_2) - P(E_1 \cap E_3) - P(E_2 \cap E_3) + P(E_1\cap E_2 \cap E_3)$.</p><h3 id="减法公式"><a href="#减法公式" class="headerlink" title="减法公式"></a>减法公式</h3><p>$P(A-B) = P(A) - P(AB) = P(A\overline{B})$</p><h3 id="条件-Conditional-概率公式"><a href="#条件-Conditional-概率公式" class="headerlink" title="条件(Conditional)概率公式"></a>条件(Conditional)概率公式</h3><p>The conditional probability of event A given the occurance of event B (denoted by $P(A|B)$) is calculated as :</p><script type="math/tex; mode=display">P(A|B) = \frac{P(A \cap B)}{P(B)}, \text{if } P(B) > 0.</script><p><strong>如何理解条件概率$P(·|A)$中的条件事件$A$？</strong></p><p>只针对$·$做概率计算，每个概率都带着$|A$即可。</p><p>例如：$P(\overline{B}|A)=P(B \cup \overline{B}|A) - P(B|A)=1-P(B|A)$, $P[(B-C|A)]=P(B|A)-P(BC|A)$.</p><h3 id="贝叶斯-Bayes-公式"><a href="#贝叶斯-Bayes-公式" class="headerlink" title="贝叶斯(Bayes)公式"></a>贝叶斯(Bayes)公式</h3><p>For two events $A$ and $B$ in the sample space $\Omega$, the conditional probability of A given B is:</p><script type="math/tex; mode=display">P(A|B)=\frac{P(AB)}{P(B)}=\frac{P(B|A)P(A)}{P(B)},</script><p>where $P(B) \neq 0$.</p><p>Moreover, if ${A_1, A_2,…, A_m}$ is a partition of $\Omega$, for each $i = 1,2,…,m$, we have:</p><script type="math/tex; mode=display">P(A_i|B)=\frac{P(A_i\cap B)}{P(B)}=\frac{P(B|A_i)P(A_i)}{\sum^m_{j=1} P(B|A_j)P(A_j)},</script><p>贝叶斯公式的本质是条件概率，描述一件基于与之相关的先验（prior）知识条件的事件的概率。</p><h3 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h3><p>if ${A_1, A_2,…, A_m}$ is a partition of $\Omega$, for any event B, we have:</p><script type="math/tex; mode=display">B=\cup^m_{i=1}A_iB, P(B)=\sum^n_{i=1} P(A_i)P(B|A_i)</script><h3 id="乘法概率公式-Joint-Probability"><a href="#乘法概率公式-Joint-Probability" class="headerlink" title="乘法概率公式(Joint Probability)"></a>乘法概率公式(Joint Probability)</h3><p>For two events A and B ($P(A)&gt;0$), we have $P(AB)=P(A)P(B|A)$.</p><p>For events $B_1,B_2,…,B_n$, we have:</p><script type="math/tex; mode=display">P(\cap^n_{i=1} B_n)=P(B_1)P(B_2|B_1)P(B_3|B_1\cap B_2)···P(B_n|\cap^n_{i=1} B_{n-1}).</script><h2 id="独立事件"><a href="#独立事件" class="headerlink" title="独立事件"></a>独立事件</h2><p>Two events A and B are <strong>independent</strong> (denoted by A $\perp$ B), if the occurance of B does not affect the probability of occurance of A, i.e., $P(A|B)=P(A)$.</p><script type="math/tex; mode=display">P(AB)=P(B)P(A|B)=P(B)P(A)</script><p><strong>Pairwise Independent（两两互斥）</strong>: A finite set of events ${A<em>i}^n</em>{i=1}$ is pairwise independent if and only if for any pairs $i \neq j$, $P(A_i \cap  A_j)=P(A_i)P(A_j)$.</p><p><strong>Mutually Independent（相互互斥）</strong>: the collection of events is mutually independent if and only if for every combination of ${i_1,i_2,…,i_k} \subset {1,2,…,n}$, we have:</p><script type="math/tex; mode=display">P(\cap^k_{j=1})=\prod^k_{j=1} P(A_{i_j}).</script><p>pairwise independent and mutually independent: mutually independent must be pairwise independent. The reverse is not true.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学基础 </tag>
            
            <tag> HKU ARIN7001 </tag>
            
            <tag> HKU ARIN7101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>就业规划</title>
      <link href="/2024/11/06/%E5%B0%B1%E4%B8%9A%E8%A7%84%E5%88%92/"/>
      <url>/2024/11/06/%E5%B0%B1%E4%B8%9A%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="就业规划"><a href="#就业规划" class="headerlink" title="就业规划"></a>就业规划</h1><p>其实这篇文章只能当成一个<strong>碎碎念</strong>了，可以简单记录一下我的就业心路历程。我真的是一个超级纠结的小女孩啊，自己想法一个月一变的那种（笑死</p><p>个人情况是国内中上985计算机科班本科毕业，AI专业港（水）硕，有两段实习，一段互联网一段投行，项目经历确实不少，感恩我的本科同学们带我。技术水平个人评定为中上，大佬必然是卷不过的，但我也不认为我技术差hhhh。</p><p>大概是从大四上学期，真的决定了要读水硕开始，我才开始真的去想<strong>就业</strong>这个问题。我的思想经历了几个转变：</p><ul><li>润出去就业</li><li>量化赛道</li><li>北京央国企等泛体制内</li><li>香港就业/日本读博</li><li>上海北京互联网就业</li></ul><p>一开始年少轻狂，觉得国内不适合我，一度很幻想国外，可能是第一次看国外的生活觉得国外就是更好（虽然我现在可能也觉得国外还是很好）但是国内并不是没有它的好处，家宝女表示不想离开家，离家爸爸妈妈姥姥还有老公(?)。我一度觉得互联网强度很高很把人当牛马以及很容易被裁员早早把互联网pass了，所以在润出去就业之后开始看我觉得下班时间合理但是钱多的岗位——然后我了解到了量化。在我找了两个月量化实习之后（当时真的在认真学习很多知识，我的python能力一直一般，所以学了很多新的库，以及学习了C++），我失败了……失败的原因是，我没有认清楚自己的能力，当时的我还是抱有我付出了老天爷就能看到我的努力就会给我我想要的东西的思想。我记得当时我做了很多公司的笔试，coding题不会，选填不会，有一个公司给了我一个项目，我花了一整天时间完成，然后被reject，有一家私募我走到了最后一关，然后终面现场coding大脑宕机了，当时的绝望我至今都还记得。<em>btw：虽然现在回想起这些感觉是没有好好准备导致的。</em>我就逐渐放弃了对量化的一切幻想。再后来我就选择了央国企等泛体制内，当时漏看了它的某个我无法忍受的弊端，现在先不提。再后来就来到了香港，秉承着来都来了为什么不试试找工作呢？以及我的第二段实习领导和我说年轻人就要拼一拼不要过早安稳，一开始觉得她资历很深开始去思考她的话，到现在我非常认同她的话。我就开始了我在香港的找summer intern之旅，转折是觉得香港找工作也不是很难？就是找工作不难，但是想要进八大投行技术岗这种就很难，我回想起了我找quant的经历，就有点想放弃，但是心态比之前好很多，试试我又不损失什么。最后最后，啊今晚好累烂尾了，就是突然很想去游戏厂，感觉在游戏厂做开发是一件我可以接受加班的工作，并且和小红书一个姐姐交流，她告诉我互联网裁员的底层逻辑，以及香港太远了我好想回到妈妈身边，我也想好了35岁失业后能做什么（目前想的是事业编）等，让我觉得很早以前pass的互联网这个和我专业最对口的选项竟然是最香的！！！但是与之而来的就是互联网最看重技术，要好好复习之前学过的没学过的CS知识，于是，为了不焦虑以及更好的学习复习暑期实习和秋招，我开了这个博客，记录我的旅程~</p><p>（还有作为一个很爱美很可爱的四坑小女孩，真的好想去上海呜呜呜…</p><p>在这些飘忽不定中，我学到了几个道理，首先要充分了解你的目标，并且知道它的bar，和它的双面性。第二点，就是要和你自己本身做一个trade-off，你最不能割舍的是什么？第三点，就是要知道个人的天花板在哪里？很多东西不是你给自己打鸡血付出时间就可以完成的（可能输在了智商上）根据这些再选择你要去做什么，并且设置目标脚踏实地地完成~尽量不要改变自己的目标！！！还有就是心态要好，一切讲究缘分，我要all in一个范围略大的目标（比如开发岗），而不是all in某个公司的开发岗~</p><h2 id="公司和岗位选择"><a href="#公司和岗位选择" class="headerlink" title="公司和岗位选择"></a>公司和岗位选择</h2><p>目前的想法是互联网为主，泛体制内等央国企为辅助。互联网比较倾向于游戏厂，当然肯定所有厂都会投递。央国企覆盖银行、运营商、三桶油（如果他要我）等一些中上等的企业。</p><p>对于岗位方面，我会<strong>all in开发岗</strong>。客观原因是算法岗更prefer有科研经历的非水硕，我除了我的毕业设计没有相关科研经历，更没有论文发表；主观原因是，我硕士读的也是AI Program，相较于本科学习的偏CS基础的东西和软件开发相关的，我好像更喜欢开发类的，对AI兴趣没有那么大。可能是我这个人性格比较急的缘故，炼丹这种活不太适合我（归功于我人比较菜hhhh）。</p><h2 id="就业准备"><a href="#就业准备" class="headerlink" title="就业准备"></a>就业准备</h2><p>我也是咨询了一些学长以及在小红书刷了不少求职帖总结的几个部分，总结了几个复习（学习）版块。</p><h3 id="简历-resume-related-questions"><a href="#简历-resume-related-questions" class="headerlink" title="简历(resume related questions)"></a>简历(resume related questions)</h3><p>简历相关，我认为可以分为自我介绍和深挖已有项目细节两方面。详细内容在另一篇博客里。</p><h3 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h3><h4 id="编程语言基础"><a href="#编程语言基础" class="headerlink" title="编程语言基础"></a>编程语言基础</h4><p>因为很想去游戏厂做服务器开发，游戏厂一般使用C++，但是大部分互联网大厂岗位都是以Java为主。所以目前打算是暑期实习准备C++，秋招如果觉得C++程度已经到80%，再准备JAVA。</p><ul><li>C++：C++部分我认为比较复杂，主要可以看侯捷的C++视频，配合《effective C++》和《C++ primer》这两本书一起学习。以及C++标准库相关的STL源码剖析学习。</li><li>Java学习：<a href="https://javaguide.cn/home.html#%E6%96%B0%E7%89%B9%E6%80%A7" target="_blank" rel="noopener">https://javaguide.cn/home.html#%E6%96%B0%E7%89%B9%E6%80%A7</a></li></ul><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>数据库可以分为MySQL和Redis。</p><ul><li>MySQL：小林Coding &amp; 书《MySQL技术内幕:InnoDB存储引擎》</li><li>Redis：小林Coding足够了</li></ul><h4 id="其他计算机基础"><a href="#其他计算机基础" class="headerlink" title="其他计算机基础"></a>其他计算机基础</h4><ul><li>计算机网络：小林Coding + 王道考研</li><li>操作系统：小林Coding + 王道考研</li><li>数据结构和算法：小林Coding没有哈哈哈，我打算看王道考研和本科学习的资料</li><li>Linux</li><li>计算机组成、编译技术等：学有余力可以复习，资料主要是本科学习材料，计组可以配合王道考研</li></ul><p>放一个小林Coding的网址：<a href="https://xiaolincoding.com/" target="_blank" rel="noopener">https://xiaolincoding.com/</a></p><h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><ul><li>leetcode</li><li>剑指offer</li></ul><h2 id="时间规划"><a href="#时间规划" class="headerlink" title="时间规划"></a>时间规划</h2><p>首先要明确，互联网暑期实习开始投递时间是<strong>2025.3</strong>，所以我需要在这个时间段之前至少复习完八股，编程题达到八成水平。</p><h3 id="第一阶段——11-9（暂定写博客的今天8）-12-15"><a href="#第一阶段——11-9（暂定写博客的今天8）-12-15" class="headerlink" title="第一阶段——11.9（暂定写博客的今天8）~12.15"></a>第一阶段——11.9（暂定写博客的今天8）~12.15</h3><p>这个阶段是master的第一个学期，考试到12.15结束，鉴于要完成剩下的assignment和project，还要参加4门课的final，所以暂时以数据库（含MySQL和Redis），计算机网络，操作系统，数据结构和算法等八股文的学习为主。顺带着开始刷leetcode，按照数据结构和算法八股文的复习顺序开始刷编程题。</p><p>更新：我觉得编程语言八股和其他计算机八股可以同步进行，就改成了，第一阶段以C++八股、数据结构和算法的八股为主。</p><h3 id="第二阶段——12-15-1-19"><a href="#第二阶段——12-15-1-19" class="headerlink" title="第二阶段——12.15~1.19"></a>第二阶段——12.15~1.19</h3><p>这段时间属于放假阶段，琐事可能有点多，比如要去找的实习地方看看，12.21放假回北京，以及花一周时间去旅游（旅游期间应该不会复习）。这段时间的任务是编程语言的八股文。</p><p>更新：第二阶段的八股主要以数据库（含MySQL和Redis），计算机网络，操作系统等其他八股文为主，可以配合着实现一些开发项目。</p><h3 id="第三阶段——1-20-2-28"><a href="#第三阶段——1-20-2-28" class="headerlink" title="第三阶段——1.20~2.28"></a>第三阶段——1.20~2.28</h3><p>这段时间属于专心冲刺期。前两个阶段专注于不同版块的八股文（按照编程语言和计算机基础划分）。这个阶段要保持编程题的手感和开始背诵八股文，强化记忆。着手准备手头的项目，优化一下个人简历，并且可以开始看牛客网和小红书的面经，加入2025暑期实习的信息群，<strong>万事俱备，只欠东风啦！</strong></p><h3 id="计划做的挺好，希望执行力也可以一样好！小蛋糕，加油-fighting！"><a href="#计划做的挺好，希望执行力也可以一样好！小蛋糕，加油-fighting！" class="headerlink" title="计划做的挺好，希望执行力也可以一样好！小蛋糕，加油~fighting！"></a>计划做的挺好，希望执行力也可以一样好！小蛋糕，加油~fighting！</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 实习和秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Theme-Snail</title>
      <link href="/2019/11/01/Hexo-Theme-Snail/"/>
      <url>/2019/11/01/Hexo-Theme-Snail/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-theme-snail"><a href="#hexo-theme-snail" class="headerlink" title="hexo-theme-snail"></a>hexo-theme-snail</h1><p><a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">View Hexo-Theme-Snail Sources On Github &#10174; </a></p><p><a href="https://www.dusign.net" target="_blank" rel="noopener">View Live Super Snail Blog &#10174;</a></p><p><img src="snail.png" alt="hexo-theme-snail"></p><p>Hexo-theme-snail is a succinct hexo theme. It has two colors, light and star, that can be set according to your own preferences in the settings, and also has the functions of sharing and commenting. More features are under development.</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>light color theme and star theme</li><li>diversified comment system</li><li>notice tips</li><li>share to other platforms (under development)</li><li>picture sharing (under development)</li></ul><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="Setup-your-blog"><a href="#Setup-your-blog" class="headerlink" title="Setup your blog"></a>Setup your blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><h3 id="Installation-Theme"><a href="#Installation-Theme" class="headerlink" title="Installation Theme"></a>Installation Theme</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ rm -rf <span class="built_in">source</span></span><br><span class="line">$ rm _config.yml package.json README.md LICENSE</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/dusign/hexo-theme-snail.git</span><br><span class="line">$ mv ./hexo-theme-snail/snail ./themes</span><br><span class="line">$ mv ./hexo-theme-snail/* ./</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="Set-Theme"><a href="#Set-Theme" class="headerlink" title="Set Theme"></a>Set Theme</h3><p>Modify the value of <code>theme:</code> in <code>_config.yml</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure></p><h3 id="Start-the-Server"><a href="#Start-the-Server" class="headerlink" title="Start the Server"></a>Start the Server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><h3 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h3><p>Replace the following information with your own.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> </span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">At</span> <span class="string">the</span> <span class="string">bottom</span> <span class="string">of</span> <span class="string">the</span> <span class="string">well,</span> <span class="string">it</span> <span class="string">is</span> <span class="string">destined</span> <span class="string">to</span> <span class="string">see</span> <span class="string">only</span> <span class="string">the</span> <span class="string">sky</span> <span class="string">at</span> <span class="string">the</span> <span class="string">wellhead.</span> </span><br><span class="line">          <span class="string">However,</span> <span class="string">the</span> <span class="string">starting</span> <span class="string">point</span> <span class="string">only</span> <span class="string">affects</span> <span class="string">the</span> <span class="string">process</span> <span class="string">of</span> <span class="string">reaching</span> <span class="string">your</span> <span class="string">peak</span> <span class="string">and</span> <span class="string">does</span> <span class="string">not</span> <span class="string">determine</span> <span class="string">the</span> <span class="string">height</span> <span class="string">you</span> <span class="string">reach.</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Dusign</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure></p><h3 id="Site-Settings"><a href="#Site-Settings" class="headerlink" title="Site Settings"></a>Site Settings</h3><p>Put customized pictures in <code>img</code> directory.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site settings</span></span><br><span class="line"><span class="attr">SEOTitle:</span> <span class="string">Hexo-theme-snail</span></span><br><span class="line"><span class="attr">email:</span> <span class="string">hexo-theme-snail@mail.com</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"A hexo theme"</span></span><br><span class="line"><span class="attr">keyword:</span> <span class="string">"dusign, hexo-theme-snail"</span></span><br><span class="line"><span class="attr">header-img:</span> <span class="string">img/header_img/home-bg-1-dark.jpg</span></span><br><span class="line"><span class="attr">signature:</span> <span class="literal">true</span> <span class="comment">#show signature</span></span><br><span class="line"><span class="attr">signature-img:</span> <span class="string">img/signature/Just-do-it-white.png</span></span><br></pre></td></tr></table></figure></p><h3 id="SNS-Settings"><a href="#SNS-Settings" class="headerlink" title="SNS Settings"></a>SNS Settings</h3><p>If you don’t want to display it, you can delete it directly.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SNS settings</span></span><br><span class="line"><span class="attr">github_username:</span>    <span class="string">dusign</span></span><br><span class="line"><span class="attr">twitter_username:</span>   <span class="string">dusignr</span></span><br><span class="line"><span class="attr">facebook_username:</span>  <span class="string">Gang</span> <span class="string">Du</span></span><br><span class="line"><span class="attr">zhihu_username:</span> <span class="string">dusignr</span></span><br></pre></td></tr></table></figure></p><h3 id="Sidebar-Settings"><a href="#Sidebar-Settings" class="headerlink" title="Sidebar Settings"></a>Sidebar Settings</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="attr">sidebar:</span> <span class="literal">true</span>                      <span class="comment"># whether or not using Sidebar.</span></span><br><span class="line"><span class="attr">sidebar-about-description:</span> <span class="string">"Welcome to visit, I'm Dusign!"</span></span><br><span class="line"><span class="attr">sidebar-avatar:</span> <span class="string">img/ironman-draw.png</span>      <span class="comment"># use absolute URL, seeing it's used in both `/` and `/about/`</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">featured-tags</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">short-about</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">recent-posts</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">friends-blog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">archive</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># widget behavior</span></span><br><span class="line"><span class="comment">## Archive</span></span><br><span class="line"><span class="attr">archive_type:</span> <span class="string">'monthly'</span></span><br><span class="line"><span class="attr">show_count:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Featured Tags</span></span><br><span class="line"><span class="attr">featured-tags:</span> <span class="literal">true</span>                     <span class="comment"># whether or not using Feature-Tags</span></span><br><span class="line"><span class="attr">featured-condition-size:</span> <span class="number">1</span>              <span class="comment"># A tag will be featured if the size of it is more than this condition value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Friends</span></span><br><span class="line"><span class="attr">friends:</span> <span class="string">[</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Blog"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://blog.csdn.net/d_Nail"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Web"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Github"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://github.com/dusign"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Other"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">github:</span> <span class="string">github.repository.address</span></span><br><span class="line">      <span class="attr">coding:</span> <span class="string">coding.repository.address</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>See httpymls://github.com/imsun/gitment for detailed configuration method.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line"><span class="comment">## This comment system is gitment</span></span><br><span class="line"><span class="comment">## gitment url: https://github.com/imsun/gitment</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">client_id:</span></span><br><span class="line">  <span class="attr">client_secret:</span></span><br></pre></td></tr></table></figure></p><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tip</span></span><br><span class="line"><span class="attr">tip:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">content:</span> <span class="string">欢迎访问</span> <span class="string">&lt;a</span> <span class="string">href="https://www.dusign.net"</span> <span class="string">target="dusign"&gt;dusign&lt;/a&gt;</span> <span class="string">的博客，博客系统一键分享的功能还在完善中，请大家耐心等待。</span></span><br><span class="line">          <span class="string">若有问题或者有好的建议欢迎留言，笔者看到之后会及时回复。</span></span><br><span class="line">          <span class="string">评论点赞需要github账号登录，如果没有账号的话请点击</span> </span><br><span class="line">          <span class="string">&lt;a</span> <span class="string">href="https://github.com"</span> <span class="string">target="view_window"</span> <span class="string">&gt;</span> <span class="string">github</span> <span class="string">&lt;/a&gt;</span> <span class="string">注册，</span> <span class="string">谢谢</span> <span class="string">!</span></span><br></pre></td></tr></table></figure><h3 id="Color-Sheme"><a href="#Color-Sheme" class="headerlink" title="Color Sheme"></a>Color Sheme</h3><p>Set the <code>enable</code> value of the desired color sheme to <code>true</code>. If the value of <code>bg_effects.star.enable</code> is <code>true</code>, please modify the value of <code>highlight_theme</code> in <code>./themes/snail/_config.yml</code> to <code>night</code>.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Color Sheme</span></span><br><span class="line"><span class="comment">## If there is no effect after modification, please empty the cache and try again.</span></span><br><span class="line"><span class="comment">## ⚠️ The following special effects will take up a lot of cpu resorces, please open it carefully.</span></span><br><span class="line"><span class="attr">bg_effects:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">color:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">pointColor:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">zIndex:</span> <span class="number">-9</span></span><br><span class="line">    <span class="attr">count:</span> <span class="number">99</span></span><br><span class="line">  <span class="attr">mouse_click:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">'"🌱","just do it","🌾","🍀","don'</span><span class="string">'t give up","🍂","🌻","try it again","🍃","never say die","🌵","🌿","🌴"'</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">'"rgb(121,93,179)"</span></span><br><span class="line"><span class="string">          ,"rgb(76,180,231)"</span></span><br><span class="line"><span class="string">          ,"rgb(184,90,154)"</span></span><br><span class="line"><span class="string">          ,"rgb(157,211,250)"</span></span><br><span class="line"><span class="string">          ,"rgb(255,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(242,153,29)"</span></span><br><span class="line"><span class="string">          ,"rgb(23,204,16)"</span></span><br><span class="line"><span class="string">          ,"rgb(222,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(22,36,92)"</span></span><br><span class="line"><span class="string">          ,"rgb(127,24,116)"</span></span><br><span class="line"><span class="string">          ,"rgb(119,195,79)"</span></span><br><span class="line"><span class="string">          ,"rgb(4,77,34)"</span></span><br><span class="line"><span class="string">          ,"rgb(122,2,60)"'</span></span><br><span class="line">  <span class="attr">star:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h2 id="如何创作一篇新文章"><a href="#如何创作一篇新文章" class="headerlink" title="如何创作一篇新文章"></a>如何创作一篇新文章</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">'article_name'</span></span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><p>此时，自动生成了.md文件并保存在source/_post文件夹中。并且，新文章部署在了github中。</p><p>在每次更新网站时，运行一下两条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure></p><h2 id="Releases"><a href="#Releases" class="headerlink" title="Releases"></a>Releases</h2><p>V1.0</p><ul><li>fix the bugs</li><li>add comment system</li><li>add notice tips</li><li>add star sheme</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Apache License 2.0 Copyright(c) 2018-2020 <a href="https://github.com/dusign" target="_blank" rel="noopener">Dusign</a>   </p><p><a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">hexo-theme-snail</a> is derived from <a href="https://github.com/Huxpro/huxpro.github.io" target="_blank" rel="noopener">Huxpro</a> Apache License 2.0. Copyright (c) 2015-2020 Huxpro</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo-theme-snail </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
